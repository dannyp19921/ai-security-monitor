This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
backend/
  gradle/
    wrapper/
      gradle-wrapper.jar
      gradle-wrapper.properties
  src/
    main/
      kotlin/
        com/
          securemonitor/
            config/
              SecurityConfig.kt
            controller/
              AdminController.kt
              AiController.kt
              AuditController.kt
              AuthController.kt
              HealthController.kt
            dto/
              AuthDtos.kt
            model/
              AuditLog.kt
              Role.kt
              User.kt
            oauth2/
              config/
                OAuth2Config.kt
              controller/
                OAuth2Controller.kt
              dto/
                OAuth2Dtos.kt
              exception/
                OAuth2Exception.kt
              model/
                AuthorizationCode.kt
                OAuth2Client.kt
              repository/
                AuthorizationCodeRepository.kt
                OAuth2ClientRepository.kt
              service/
                AuthorizationService.kt
                PkceService.kt
                TokenService.kt
              README.md
            repository/
              AuditLogRepository.kt
              RoleRepository.kt
              UserRepository.kt
            security/
              JwtAuthenticationFilter.kt
              JwtService.kt
              OAuth2AuthenticationSuccessHandler.kt
            service/
              AiService.kt
              AuditService.kt
              AuthService.kt
            BackendApplication.kt
      resources/
        application.yml
    test/
      kotlin/
        com/
          securemonitor/
            oauth2/
              service/
                AuthorizationServiceTest.kt
                PkceServiceTest.kt
                TokenServiceTest.kt
            BackendApplicationTests.kt
  .gitattributes
  .gitignore
  build.gradle.kts
  Dockerfile
  gradlew
  gradlew.bat
  settings.gradle.kts
docker/
  docker-compose.yml
frontend/
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      admin/
        AdminPanel.tsx
      auth/
        LoginForm.tsx
        RegisterForm.tsx
      chat/
        AiChat.tsx
      ui/
        Button.tsx
        Input.tsx
    hooks/
      useAuth.ts
    pages/
      DashboardPage.tsx
      LoginPage.tsx
    services/
      api.ts
    types/
      index.ts
    App.css
    App.tsx
    index.css
    main.tsx
  .gitignore
  eslint.config.js
  index.html
  package.json
  README.md
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
infrastructure/
  helm/
    ai-security-monitor/
      templates/
        _helpers.tpl
        configmap.yaml
        deployment.yaml
        ingress.yaml
        secret.yaml
        service.yaml
        serviceaccount.yaml
      Chart.yaml
      values.yaml
  kubernetes/
    backend-deployment.yaml
    backend-service.yaml
    configmap.yaml
    ingress.yaml
    kustomization.yaml
    namespace.yaml
    postgres.yaml
    README.md
    secrets.yaml
  README.md
.gitignore
docker-compose.yml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/main/kotlin/com/securemonitor/security/OAuth2AuthenticationSuccessHandler.kt">
// backend/src/main/kotlin/com/securemonitor/security/OAuth2AuthenticationSuccessHandler.kt
package com.securemonitor.security

import com.securemonitor.model.User
import com.securemonitor.repository.RoleRepository
import com.securemonitor.repository.UserRepository
import com.securemonitor.service.AuditService
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.core.Authentication
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.oauth2.core.user.OAuth2User
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler
import org.springframework.stereotype.Component
import org.springframework.web.util.UriComponentsBuilder
import java.util.*

/**
 * Custom success handler for OAuth2 login.
 * 
 * Flow:
 * 1. User authenticates with Google
 * 2. We receive OAuth2User with Google profile info
 * 3. We map to local User (create if doesn't exist)
 * 4. We generate JWT token
 * 5. We redirect to frontend with JWT as query parameter
 */
@Component
class OAuth2AuthenticationSuccessHandler(
    private val jwtService: JwtService,
    private val userRepository: UserRepository,
    private val roleRepository: RoleRepository,
    private val passwordEncoder: PasswordEncoder,
    private val auditService: AuditService
) : SimpleUrlAuthenticationSuccessHandler() {

    override fun onAuthenticationSuccess(
        request: HttpServletRequest,
        response: HttpServletResponse,
        authentication: Authentication
    ) {
        val oauth2User = authentication.principal as OAuth2User
        
        // Extract user info from Google
        val email = oauth2User.getAttribute<String>("email") 
            ?: throw IllegalStateException("Email not available from OAuth2 provider")
        val name = oauth2User.getAttribute<String>("name") ?: email
        val givenName = oauth2User.getAttribute<String>("given_name") ?: ""
        val familyName = oauth2User.getAttribute<String>("family_name") ?: ""
        
        // Find or create local user
        val user = userRepository.findByUsername(email).orElseGet {
            createNewUser(email, name, givenName, familyName)
        }
        
        // Generate JWT token
        val token = jwtService.generateToken(user.username, user.roles.map { it.name })
        
        // Log successful OAuth2 login
        auditService.log(
            action = "OAUTH2_LOGIN_SUCCESS",
            username = user.username,
            resourceType = "USER",
            resourceId = user.id.toString(),
            ipAddress = request.remoteAddr,
            details = "Logged in via Google OAuth2",
            success = true
        )
        
        // Redirect to frontend with JWT token
        val targetUrl = buildRedirectUrl(token)
        
        logger.debug("Redirecting OAuth2 user ${user.username} to: $targetUrl")
        
        redirectStrategy.sendRedirect(request, response, targetUrl)
    }
    
    private fun createNewUser(email: String, name: String, givenName: String, familyName: String): User {
        logger.info("Creating new user from OAuth2 login: $email")
        
        val userRole = roleRepository.findByName("USER")
            .orElseThrow { IllegalStateException("USER role not found in database") }
        
        val newUser = User(
            username = email,
            email = email,  
            // Generate random password (user won't use it - they login via OAuth2)
            passwordHash = passwordEncoder.encode(UUID.randomUUID().toString()),
            roles = mutableSetOf(userRole)
        )
        
        return userRepository.save(newUser)
    }
    
    private fun buildRedirectUrl(token: String): String {
        // Redirect to frontend with JWT token as query parameter
        // Frontend will extract token and store it
        val frontendUrl = System.getenv("FRONTEND_URL") 
            ?: "http://localhost:5173"
        
        return UriComponentsBuilder.fromUriString(frontendUrl)
            .path("/oauth2/callback")
            .queryParam("token", token)
            .build()
            .toUriString()
    }
}
</file>

<file path="backend/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="backend/src/main/kotlin/com/securemonitor/controller/AiController.kt">
// backend/src/main/kotlin/com/securemonitor/controller/AiController.kt
package com.securemonitor.controller

import com.securemonitor.dto.ChatRequest
import com.securemonitor.dto.ChatResponse
import com.securemonitor.service.AiService
import org.springframework.http.ResponseEntity
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/ai")
class AiController(
    private val aiService: AiService
) {

    @PostMapping("/chat")
    fun chat(@RequestBody request: ChatRequest): ResponseEntity<ChatResponse> {
        val username = SecurityContextHolder.getContext().authentication?.name ?: "anonymous"
        val response = aiService.chat(request.message, username)

        return ResponseEntity.ok(ChatResponse(response = response))
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/controller/AuditController.kt">
// backend/src/main/kotlin/com/securemonitor/controller/AuditController.kt
package com.securemonitor.controller

import com.securemonitor.model.AuditLog
import com.securemonitor.service.AuditService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/audit")
class AuditController(
    private val auditService: AuditService
) {

    @GetMapping("/logs")
    fun getRecentLogs(): ResponseEntity<List<AuditLog>> {
        return ResponseEntity.ok(auditService.getRecentLogs())
    }

    @GetMapping("/logs/user/{username}")
    fun getLogsByUsername(@PathVariable username: String): ResponseEntity<List<AuditLog>> {
        return ResponseEntity.ok(auditService.getLogsByUsername(username))
    }

    @GetMapping("/logs/action/{action}")
    fun getLogsByAction(@PathVariable action: String): ResponseEntity<List<AuditLog>> {
        return ResponseEntity.ok(auditService.getLogsByAction(action))
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/controller/HealthController.kt">
// backend/src/main/kotlin/com/securemonitor/controller/HealthController.kt
package com.securemonitor.controller

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.time.Instant

@RestController
@RequestMapping("/api")
class HealthController {

    @GetMapping("/health")
    fun health(): Map<String, Any> {
        return mapOf(
            "status" to "UP",
            "service" to "ai-security-monitor",
            "timestamp" to Instant.now().toString()
        )
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/model/AuditLog.kt">
// backend/src/main/kotlin/com/securemonitor/model/AuditLog.kt
package com.securemonitor.model

import jakarta.persistence.*
import java.time.Instant

@Entity
@Table(name = "audit_logs")
data class AuditLog(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(nullable = false)
    val timestamp: Instant = Instant.now(),

    @Column(nullable = false)
    val action: String,

    @Column(nullable = false)
    val username: String,

    @Column
    val resourceType: String? = null,

    @Column
    val resourceId: String? = null,

    @Column
    val ipAddress: String? = null,

    @Column(length = 1000)
    val details: String? = null,

    @Column(nullable = false)
    val success: Boolean = true
)
</file>

<file path="backend/src/main/kotlin/com/securemonitor/model/Role.kt">
// backend/src/main/kotlin/com/securemonitor/model/Role.kt
package com.securemonitor.model

import jakarta.persistence.*

@Entity
@Table(name = "roles")
data class Role(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(unique = true, nullable = false)
    val name: String,

    @Column
    val description: String? = null
)
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/config/OAuth2Config.kt">
package com.securemonitor.oauth2.config

import com.securemonitor.oauth2.model.OAuth2Client
import com.securemonitor.oauth2.repository.OAuth2ClientRepository
import org.slf4j.LoggerFactory
import org.springframework.boot.CommandLineRunner
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

/**
 * Configuration properties for OAuth 2.0 / OIDC.
 */
@Configuration
@ConfigurationProperties(prefix = "oauth2")
class OAuth2Config {
    
    /** The issuer identifier (typically the base URL of the authorization server) */
    var issuer: String = "http://localhost:8080"
    
    /** Access token lifetime in seconds */
    var accessTokenLifetime: Long = 3600 // 1 hour
    
    /** Refresh token lifetime in seconds */
    var refreshTokenLifetime: Long = 86400 * 30 // 30 days
    
    /** Authorization code lifetime in seconds */
    var authorizationCodeLifetime: Long = 600 // 10 minutes
    
    /** Whether to require PKCE for all public clients */
    var requirePkce: Boolean = true
}

/**
 * Initializes default OAuth2 clients for development/testing.
 */
@Configuration
class OAuth2ClientInitializer {
    
    private val log = LoggerFactory.getLogger(OAuth2ClientInitializer::class.java)
    
    /**
     * Creates default OAuth2 clients for development.
     * In production, clients would be registered through an admin API.
     */
    @Bean
    fun initializeOAuth2Clients(clientRepository: OAuth2ClientRepository) = CommandLineRunner {
        // Create a demo client for the frontend
        if (!clientRepository.existsByClientId("ai-security-monitor-frontend")) {
            val frontendClient = OAuth2Client(
                clientId = "ai-security-monitor-frontend",
                clientSecretHash = null, // Public client, uses PKCE
                clientName = "AI Security Monitor Frontend",
                description = "The React frontend application",
                confidential = false,
                redirectUris = listOf(
                    "http://localhost:5173/callback",
                    "http://localhost:5173/oauth/callback",
                    "http://localhost:3000/callback",
                    "https://ai-security-monitor.vercel.app/callback",
                    "https://ai-security-monitor.vercel.app/oauth/callback"
                ).joinToString(","),
                allowedScopes = "openid profile email",
                allowedGrantTypes = "authorization_code refresh_token",
                requirePkce = true,
                accessTokenLifetimeSeconds = 3600,
                refreshTokenLifetimeSeconds = 86400 * 7
            )
            
            clientRepository.save(frontendClient)
            log.info("Created default OAuth2 client: ai-security-monitor-frontend")
        }
        
        // Create a demo client for testing
        if (!clientRepository.existsByClientId("test-client")) {
            val testClient = OAuth2Client(
                clientId = "test-client",
                clientSecretHash = null,
                clientName = "Test Client",
                description = "A test client for development",
                confidential = false,
                redirectUris = "http://localhost:3000/callback,http://127.0.0.1:3000/callback",
                allowedScopes = "openid profile email",
                allowedGrantTypes = "authorization_code refresh_token",
                requirePkce = true,
                accessTokenLifetimeSeconds = 3600,
                refreshTokenLifetimeSeconds = 86400
            )
            
            clientRepository.save(testClient)
            log.info("Created default OAuth2 client: test-client")
        }
        
        // Create a confidential client example (for server-to-server)
        if (!clientRepository.existsByClientId("confidential-client")) {
            val confidentialClient = OAuth2Client(
                clientId = "confidential-client",
                // In production, this would be a properly hashed secret
                clientSecretHash = "\$2a\$10\$dummyHashForDemoOnly",
                clientName = "Confidential Backend Client",
                description = "A confidential client for backend services",
                confidential = true,
                redirectUris = "http://localhost:8081/callback",
                allowedScopes = "openid profile email admin",
                allowedGrantTypes = "authorization_code refresh_token client_credentials",
                requirePkce = false, // Confidential clients can use client_secret instead
                accessTokenLifetimeSeconds = 3600,
                refreshTokenLifetimeSeconds = 86400 * 30
            )
            
            clientRepository.save(confidentialClient)
            log.info("Created default OAuth2 client: confidential-client")
        }
        
        log.info("OAuth2 client initialization complete")
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/controller/OAuth2Controller.kt">
package com.securemonitor.oauth2.controller

import com.securemonitor.oauth2.dto.*
import com.securemonitor.oauth2.exception.OAuth2Exception
import com.securemonitor.oauth2.service.AuthorizationService
import com.securemonitor.oauth2.service.TokenService
import com.securemonitor.repository.UserRepository
import com.securemonitor.service.AuditService
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.security.Keys
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpSession
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.*
import java.util.Base64

/**
 * OAuth 2.0 / OpenID Connect Controller.
 * 
 * Implements the following endpoints:
 * - GET  /oauth2/authorize     - Authorization endpoint
 * - POST /oauth2/token         - Token endpoint
 * - GET  /oauth2/userinfo      - UserInfo endpoint (OIDC)
 * - GET  /.well-known/openid-configuration - Discovery document
 * - GET  /.well-known/jwks.json - JSON Web Key Set
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749">RFC 6749 - OAuth 2.0</a>
 * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core</a>
 */
@RestController
class OAuth2Controller(
    private val authorizationService: AuthorizationService,
    private val tokenService: TokenService,
    private val userRepository: UserRepository,
    private val auditService: AuditService,
    @Value("\${oauth2.issuer:http://localhost:8080}")
    private val issuer: String,
    @Value("\${jwt.secret:myDefaultSecretKeyThatIsAtLeast256BitsLong123456}")
    private val jwtSecret: String
) {
    private val log = LoggerFactory.getLogger(OAuth2Controller::class.java)

    /**
     * Authorization endpoint.
     * 
     * This endpoint initiates the OAuth 2.0 authorization flow. It:
     * 1. Validates the authorization request
     * 2. Authenticates the user (if not already authenticated)
     * 3. Obtains user consent
     * 4. Redirects back to the client with an authorization code
     * 
     * In a production system, this would render a consent page. For this
     * demo, we auto-consent if the user is authenticated.
     * 
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1">RFC 6749 Section 4.1.1</a>
     */
    @GetMapping("/oauth2/authorize")
    fun authorize(
        @RequestParam("response_type") responseType: String,
        @RequestParam("client_id") clientId: String,
        @RequestParam("redirect_uri") redirectUri: String,
        @RequestParam("scope", required = false) scope: String?,
        @RequestParam("state", required = false) state: String?,
        @RequestParam("code_challenge", required = false) codeChallenge: String?,
        @RequestParam("code_challenge_method", required = false, defaultValue = "S256") codeChallengeMethod: String?,
        @RequestParam("nonce", required = false) nonce: String?,
        request: HttpServletRequest
    ): ResponseEntity<Any> {
        log.debug("Authorization request received for client: {}", clientId)
        
        val authRequest = AuthorizationRequest(
            responseType = responseType,
            clientId = clientId,
            redirectUri = redirectUri,
            scope = scope,
            state = state,
            codeChallenge = codeChallenge,
            codeChallengeMethod = codeChallengeMethod,
            nonce = nonce
        )
        
        return try {
            // Validate the request
            val client = authorizationService.validateAuthorizationRequest(authRequest)
            
            // Check if user is authenticated
            val authentication = SecurityContextHolder.getContext().authentication
            if (authentication == null || !authentication.isAuthenticated || 
                authentication.principal == "anonymousUser") {
                // Store request in session and redirect to login
                request.session.setAttribute("oauth2_request", authRequest)
                return ResponseEntity.status(HttpStatus.FOUND)
                    .header("Location", "/login?oauth2=true")
                    .build()
            }
            
            // Get user details
            val username = authentication.name
            val user = userRepository.findByUsername(username).orElseThrow {
                OAuth2Exception.serverError("User not found")
            }
            
            // In production, show consent screen here
            // For demo, we auto-consent
            
            // Create authorization code
            val authCode = authorizationService.createAuthorizationCode(
                client = client,
                request = authRequest,
                userId = user.id,
                username = username
            )
            
            // Build redirect URL
            val redirectUrl = authorizationService.buildAuthorizationRedirect(
                baseRedirectUri = redirectUri,
                code = authCode.code,
                state = state
            )
            
            log.info("Authorization successful, redirecting to: {}", redirectUri)
            ResponseEntity.status(HttpStatus.FOUND)
                .header("Location", redirectUrl)
                .build()
                
        } catch (e: OAuth2Exception) {
            log.warn("Authorization failed: {}", e.errorDescription)
            
            // For security errors that occur before redirect_uri validation,
            // we should not redirect (to prevent open redirect attacks)
            if (e.error == "invalid_client" || e.error == "invalid_request" && 
                e.errorDescription?.contains("redirect_uri") == true) {
                return ResponseEntity.badRequest()
                    .body(e.toErrorResponse())
            }
            
            // For other errors, redirect with error
            val errorRedirect = authorizationService.buildErrorRedirect(
                baseRedirectUri = redirectUri,
                error = e.error,
                errorDescription = e.errorDescription,
                state = state
            )
            ResponseEntity.status(HttpStatus.FOUND)
                .header("Location", errorRedirect)
                .build()
        }
    }

    /**
     * Token endpoint.
     * 
     * Exchanges an authorization code or refresh token for access tokens.
     * 
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">RFC 6749 Section 4.1.3</a>
     */
    @PostMapping("/oauth2/token", consumes = [MediaType.APPLICATION_FORM_URLENCODED_VALUE])
    fun token(
        @RequestParam("grant_type") grantType: String,
        @RequestParam("code", required = false) code: String?,
        @RequestParam("redirect_uri", required = false) redirectUri: String?,
        @RequestParam("client_id", required = false) clientId: String?,
        @RequestParam("client_secret", required = false) clientSecret: String?,
        @RequestParam("code_verifier", required = false) codeVerifier: String?,
        @RequestParam("refresh_token", required = false) refreshToken: String?,
        @RequestParam("scope", required = false) scope: String?,
        request: HttpServletRequest
    ): ResponseEntity<Any> {
        log.debug("Token request received. Grant type: {}", grantType)
        
        // Extract client credentials from Authorization header if present
        val (headerClientId, headerClientSecret) = extractBasicAuth(request)
        
        val tokenRequest = TokenRequest(
            grantType = grantType,
            code = code,
            redirectUri = redirectUri,
            clientId = clientId ?: headerClientId,
            clientSecret = clientSecret ?: headerClientSecret,
            codeVerifier = codeVerifier,
            refreshToken = refreshToken,
            scope = scope
        )
        
        return try {
            val response = when (grantType) {
                "authorization_code" -> tokenService.exchangeAuthorizationCode(tokenRequest)
                "refresh_token" -> {
                    // TODO: Implement refresh token flow
                    throw OAuth2Exception.unsupportedGrantType("refresh_token (not yet implemented)")
                }
                else -> throw OAuth2Exception.unsupportedGrantType(grantType)
            }
            
            ResponseEntity.ok()
                .header("Cache-Control", "no-store")
                .header("Pragma", "no-cache")
                .body(response)
                
        } catch (e: OAuth2Exception) {
            log.warn("Token request failed: {}", e.errorDescription)
            ResponseEntity.status(e.httpStatus)
                .body(e.toErrorResponse())
        }
    }

    /**
     * Token endpoint with JSON body (alternative).
     */
    @PostMapping("/oauth2/token", consumes = [MediaType.APPLICATION_JSON_VALUE])
    fun tokenJson(@RequestBody tokenRequest: TokenRequest, request: HttpServletRequest): ResponseEntity<Any> {
        return token(
            grantType = tokenRequest.grantType,
            code = tokenRequest.code,
            redirectUri = tokenRequest.redirectUri,
            clientId = tokenRequest.clientId,
            clientSecret = tokenRequest.clientSecret,
            codeVerifier = tokenRequest.codeVerifier,
            refreshToken = tokenRequest.refreshToken,
            scope = tokenRequest.scope,
            request = request
        )
    }

    /**
     * UserInfo endpoint.
     * 
     * Returns claims about the authenticated user.
     * Requires a valid access token with the 'openid' scope.
     * 
     * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">OIDC UserInfo</a>
     */
    @GetMapping("/oauth2/userinfo")
    fun userInfo(): ResponseEntity<Any> {
        val authentication = SecurityContextHolder.getContext().authentication
        
        if (authentication == null || !authentication.isAuthenticated) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(mapOf("error" to "invalid_token", "error_description" to "Access token is required"))
        }
        
        val username = authentication.name
        val user = userRepository.findByUsername(username).orElse(null)
            ?: return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(mapOf("error" to "invalid_token", "error_description" to "User not found"))
        
        val userInfo = UserInfoResponse(
            sub = user.id.toString(),
            preferredUsername = user.username,
            email = user.email,
            emailVerified = true, // In production, track this separately
            updatedAt = user.createdAt.epochSecond
        )
        
        return ResponseEntity.ok(userInfo)
    }

    /**
     * OpenID Connect Discovery document.
     * 
     * @see <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OIDC Discovery</a>
     */
    @GetMapping("/.well-known/openid-configuration")
    fun openIdConfiguration(): ResponseEntity<OpenIdConfiguration> {
        val config = OpenIdConfiguration(
            issuer = issuer,
            authorizationEndpoint = "$issuer/oauth2/authorize",
            tokenEndpoint = "$issuer/oauth2/token",
            userinfoEndpoint = "$issuer/oauth2/userinfo",
            jwksUri = "$issuer/.well-known/jwks.json",
            responseTypesSupported = listOf("code"),
            grantTypesSupported = listOf("authorization_code", "refresh_token"),
            subjectTypesSupported = listOf("public"),
            idTokenSigningAlgValuesSupported = listOf("HS256"), // Using HMAC for demo
            scopesSupported = listOf("openid", "profile", "email"),
            tokenEndpointAuthMethodsSupported = listOf("client_secret_basic", "client_secret_post", "none"),
            codeChallengeMethodsSupported = listOf("S256", "plain"),
            claimsSupported = listOf(
                "sub", "iss", "aud", "exp", "iat", "auth_time",
                "nonce", "preferred_username", "email", "email_verified"
            )
        )
        
        return ResponseEntity.ok(config)
    }

    /**
     * JSON Web Key Set endpoint.
     * 
     * In production, this would expose the public key(s) used to sign tokens.
     * For this demo using HMAC, we return minimal information.
     * 
     * @see <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517 - JWK</a>
     */
    @GetMapping("/.well-known/jwks.json")
    fun jwks(): ResponseEntity<JwksResponse> {
        // Note: For HMAC signing, we don't expose the key
        // In production with RSA, you would expose the public key here
        val jwks = JwksResponse(
            keys = listOf(
                JwkKey(
                    kty = "oct", // Octet sequence (symmetric)
                    use = "sig",
                    kid = "default-key",
                    alg = "HS256"
                )
            )
        )
        
        return ResponseEntity.ok(jwks)
    }

    /**
     * Extracts client credentials from the Authorization header (Basic auth).
     */
    private fun extractBasicAuth(request: HttpServletRequest): Pair<String?, String?> {
        val authHeader = request.getHeader("Authorization") ?: return Pair(null, null)
        
        if (!authHeader.startsWith("Basic ")) return Pair(null, null)
        
        return try {
            val credentials = String(Base64.getDecoder().decode(authHeader.substring(6)))
            val parts = credentials.split(":", limit = 2)
            if (parts.size == 2) Pair(parts[0], parts[1]) else Pair(null, null)
        } catch (e: Exception) {
            Pair(null, null)
        }
    }

    /**
     * Global exception handler for OAuth2 errors.
     */
    @ExceptionHandler(OAuth2Exception::class)
    fun handleOAuth2Exception(e: OAuth2Exception): ResponseEntity<Map<String, String?>> {
        log.warn("OAuth2 error: {} - {}", e.error, e.errorDescription)
        return ResponseEntity.status(e.httpStatus).body(e.toErrorResponse())
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/dto/OAuth2Dtos.kt">
package com.securemonitor.oauth2.dto

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.annotation.JsonProperty
import java.time.Instant

/**
 * Request parameters for the authorization endpoint (/oauth2/authorize).
 * 
 * This follows RFC 6749 Section 4.1.1 and RFC 7636 for PKCE parameters.
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1">RFC 6749 Section 4.1.1</a>
 */
data class AuthorizationRequest(
    /** The type of response expected. Must be "code" for authorization code flow. */
    @JsonProperty("response_type")
    val responseType: String,
    
    /** The client identifier registered with the authorization server. */
    @JsonProperty("client_id")
    val clientId: String,
    
    /** The URI to redirect the user-agent after authorization. */
    @JsonProperty("redirect_uri")
    val redirectUri: String,
    
    /** Space-delimited list of requested scopes. */
    val scope: String? = null,
    
    /** Opaque value to maintain state between request and callback. */
    val state: String? = null,
    
    /** PKCE code challenge (required for public clients). */
    @JsonProperty("code_challenge")
    val codeChallenge: String? = null,
    
    /** PKCE code challenge method (S256 recommended). */
    @JsonProperty("code_challenge_method")
    val codeChallengeMethod: String? = "S256",
    
    /** Optional nonce for ID token replay protection (OIDC). */
    val nonce: String? = null
) {
    companion object {
        const val RESPONSE_TYPE_CODE = "code"
        const val RESPONSE_TYPE_TOKEN = "token" // Implicit flow (not recommended)
    }
}

/**
 * Request body for the token endpoint (/oauth2/token).
 * 
 * Supports multiple grant types as defined in RFC 6749.
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">RFC 6749 Section 4.1.3</a>
 */
data class TokenRequest(
    /** The grant type being used. */
    @JsonProperty("grant_type")
    val grantType: String,
    
    /** Authorization code (for authorization_code grant). */
    val code: String? = null,
    
    /** Redirect URI (must match the one used in authorization request). */
    @JsonProperty("redirect_uri")
    val redirectUri: String? = null,
    
    /** Client identifier. */
    @JsonProperty("client_id")
    val clientId: String? = null,
    
    /** Client secret (for confidential clients). */
    @JsonProperty("client_secret")
    val clientSecret: String? = null,
    
    /** PKCE code verifier. */
    @JsonProperty("code_verifier")
    val codeVerifier: String? = null,
    
    /** Refresh token (for refresh_token grant). */
    @JsonProperty("refresh_token")
    val refreshToken: String? = null,
    
    /** Requested scope (for refresh_token grant, must be subset of original). */
    val scope: String? = null,
    
    /** Username (for password grant - deprecated). */
    val username: String? = null,
    
    /** Password (for password grant - deprecated). */
    val password: String? = null
) {
    companion object {
        const val GRANT_TYPE_AUTHORIZATION_CODE = "authorization_code"
        const val GRANT_TYPE_REFRESH_TOKEN = "refresh_token"
        const val GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials"
        const val GRANT_TYPE_PASSWORD = "password" // Deprecated, avoid using
    }
}

/**
 * Token response from the token endpoint.
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-5.1">RFC 6749 Section 5.1</a>
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
data class TokenResponse(
    /** The access token issued by the authorization server. */
    @JsonProperty("access_token")
    val accessToken: String,
    
    /** The type of token (typically "Bearer"). */
    @JsonProperty("token_type")
    val tokenType: String = "Bearer",
    
    /** The lifetime of the access token in seconds. */
    @JsonProperty("expires_in")
    val expiresIn: Long,
    
    /** The refresh token (if issued). */
    @JsonProperty("refresh_token")
    val refreshToken: String? = null,
    
    /** The scope of the access token. */
    val scope: String? = null,
    
    /** ID token (OIDC only). */
    @JsonProperty("id_token")
    val idToken: String? = null
)

/**
 * User info response from the userinfo endpoint (OIDC).
 * 
 * @see <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse">OIDC UserInfo Response</a>
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
data class UserInfoResponse(
    /** Subject identifier (unique user ID). */
    val sub: String,
    
    /** User's preferred username. */
    @JsonProperty("preferred_username")
    val preferredUsername: String? = null,
    
    /** User's email address. */
    val email: String? = null,
    
    /** Whether email is verified. */
    @JsonProperty("email_verified")
    val emailVerified: Boolean? = null,
    
    /** User's full name. */
    val name: String? = null,
    
    /** User's given (first) name. */
    @JsonProperty("given_name")
    val givenName: String? = null,
    
    /** User's family (last) name. */
    @JsonProperty("family_name")
    val familyName: String? = null,
    
    /** User's locale. */
    val locale: String? = null,
    
    /** Time user info was last updated. */
    @JsonProperty("updated_at")
    val updatedAt: Long? = null
)

/**
 * Authorization code stored during the authorization flow.
 * This is an internal DTO, not exposed via API.
 */
data class StoredAuthorizationCode(
    /** The authorization code value. */
    val code: String,
    
    /** Client ID that requested authorization. */
    val clientId: String,
    
    /** User who authorized the request. */
    val userId: Long,
    
    /** Redirect URI used in the request. */
    val redirectUri: String,
    
    /** Granted scopes. */
    val scope: String?,
    
    /** PKCE code challenge. */
    val codeChallenge: String?,
    
    /** PKCE code challenge method. */
    val codeChallengeMethod: String?,
    
    /** Nonce for ID token (OIDC). */
    val nonce: String?,
    
    /** When the code was issued. */
    val issuedAt: Instant = Instant.now(),
    
    /** When the code expires. */
    val expiresAt: Instant = Instant.now().plusSeconds(600), // 10 minutes default
    
    /** Whether the code has been used (codes are single-use). */
    var used: Boolean = false
) {
    /** Check if the code has expired. */
    fun isExpired(): Boolean = Instant.now().isAfter(expiresAt)
    
    /** Check if the code is still valid (not expired and not used). */
    fun isValid(): Boolean = !isExpired() && !used
}

/**
 * JWKS (JSON Web Key Set) response.
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a>
 */
data class JwksResponse(
    val keys: List<JwkKey>
)

/**
 * Individual JWK (JSON Web Key).
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
data class JwkKey(
    /** Key type (e.g., "RSA", "EC"). */
    val kty: String,
    
    /** Intended use ("sig" for signature, "enc" for encryption). */
    val use: String? = "sig",
    
    /** Key ID. */
    val kid: String,
    
    /** Algorithm (e.g., "RS256"). */
    val alg: String? = null,
    
    /** RSA modulus (Base64URL encoded). */
    val n: String? = null,
    
    /** RSA exponent (Base64URL encoded). */
    val e: String? = null
)

/**
 * OpenID Connect Discovery document.
 * 
 * @see <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OIDC Discovery</a>
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
data class OpenIdConfiguration(
    /** Issuer identifier. */
    val issuer: String,
    
    /** Authorization endpoint URL. */
    @JsonProperty("authorization_endpoint")
    val authorizationEndpoint: String,
    
    /** Token endpoint URL. */
    @JsonProperty("token_endpoint")
    val tokenEndpoint: String,
    
    /** UserInfo endpoint URL. */
    @JsonProperty("userinfo_endpoint")
    val userinfoEndpoint: String,
    
    /** JWKS URI. */
    @JsonProperty("jwks_uri")
    val jwksUri: String,
    
    /** Supported response types. */
    @JsonProperty("response_types_supported")
    val responseTypesSupported: List<String> = listOf("code"),
    
    /** Supported grant types. */
    @JsonProperty("grant_types_supported")
    val grantTypesSupported: List<String> = listOf(
        "authorization_code",
        "refresh_token"
    ),
    
    /** Supported subject types. */
    @JsonProperty("subject_types_supported")
    val subjectTypesSupported: List<String> = listOf("public"),
    
    /** Supported ID token signing algorithms. */
    @JsonProperty("id_token_signing_alg_values_supported")
    val idTokenSigningAlgValuesSupported: List<String> = listOf("RS256"),
    
    /** Supported scopes. */
    @JsonProperty("scopes_supported")
    val scopesSupported: List<String> = listOf("openid", "profile", "email"),
    
    /** Supported token endpoint authentication methods. */
    @JsonProperty("token_endpoint_auth_methods_supported")
    val tokenEndpointAuthMethodsSupported: List<String> = listOf(
        "client_secret_basic",
        "client_secret_post"
    ),
    
    /** Supported code challenge methods. */
    @JsonProperty("code_challenge_methods_supported")
    val codeChallengeMethodsSupported: List<String> = listOf("S256", "plain"),
    
    /** Supported claims. */
    @JsonProperty("claims_supported")
    val claimsSupported: List<String> = listOf(
        "sub", "iss", "aud", "exp", "iat",
        "name", "email", "email_verified", "preferred_username"
    )
)
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/exception/OAuth2Exception.kt">
package com.securemonitor.oauth2.exception

import org.springframework.http.HttpStatus

/**
 * Exception representing OAuth 2.0 error responses.
 * 
 * Follows RFC 6749 Section 4.1.2.1 and 5.2 for error response format.
 * All OAuth 2.0 errors should use this exception to ensure consistent
 * error responses across all endpoints.
 * 
 * @property error The OAuth 2.0 error code (e.g., "invalid_request", "invalid_grant")
 * @property errorDescription Human-readable description of the error
 * @property errorUri Optional URI pointing to documentation about the error
 * @property httpStatus The HTTP status code to return
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1">RFC 6749 Section 4.1.2.1</a>
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-5.2">RFC 6749 Section 5.2</a>
 */
class OAuth2Exception(
    val error: String,
    val errorDescription: String? = null,
    val errorUri: String? = null,
    val httpStatus: HttpStatus = HttpStatus.BAD_REQUEST
) : RuntimeException(errorDescription ?: error) {

    companion object {
        /**
         * Standard OAuth 2.0 error codes as defined in RFC 6749.
         */
        object ErrorCodes {
            /** The request is malformed or missing required parameters */
            const val INVALID_REQUEST = "invalid_request"
            
            /** Client authentication failed */
            const val INVALID_CLIENT = "invalid_client"
            
            /** The provided authorization grant is invalid or expired */
            const val INVALID_GRANT = "invalid_grant"
            
            /** The client is not authorized for this grant type */
            const val UNAUTHORIZED_CLIENT = "unauthorized_client"
            
            /** The grant type is not supported */
            const val UNSUPPORTED_GRANT_TYPE = "unsupported_grant_type"
            
            /** The requested scope is invalid or exceeds granted scope */
            const val INVALID_SCOPE = "invalid_scope"
            
            /** The resource owner denied the request */
            const val ACCESS_DENIED = "access_denied"
            
            /** The response type is not supported */
            const val UNSUPPORTED_RESPONSE_TYPE = "unsupported_response_type"
            
            /** The server encountered an unexpected error */
            const val SERVER_ERROR = "server_error"
            
            /** The server is temporarily unavailable */
            const val TEMPORARILY_UNAVAILABLE = "temporarily_unavailable"
        }

        /**
         * Factory methods for common OAuth 2.0 errors.
         */
        fun invalidRequest(description: String) = OAuth2Exception(
            error = ErrorCodes.INVALID_REQUEST,
            errorDescription = description,
            httpStatus = HttpStatus.BAD_REQUEST
        )

        fun invalidClient(description: String) = OAuth2Exception(
            error = ErrorCodes.INVALID_CLIENT,
            errorDescription = description,
            httpStatus = HttpStatus.UNAUTHORIZED
        )

        fun invalidGrant(description: String) = OAuth2Exception(
            error = ErrorCodes.INVALID_GRANT,
            errorDescription = description,
            httpStatus = HttpStatus.BAD_REQUEST
        )

        fun unauthorizedClient(description: String) = OAuth2Exception(
            error = ErrorCodes.UNAUTHORIZED_CLIENT,
            errorDescription = description,
            httpStatus = HttpStatus.FORBIDDEN
        )

        fun unsupportedGrantType(grantType: String) = OAuth2Exception(
            error = ErrorCodes.UNSUPPORTED_GRANT_TYPE,
            errorDescription = "Grant type '$grantType' is not supported",
            httpStatus = HttpStatus.BAD_REQUEST
        )

        fun invalidScope(description: String) = OAuth2Exception(
            error = ErrorCodes.INVALID_SCOPE,
            errorDescription = description,
            httpStatus = HttpStatus.BAD_REQUEST
        )

        fun accessDenied(description: String) = OAuth2Exception(
            error = ErrorCodes.ACCESS_DENIED,
            errorDescription = description,
            httpStatus = HttpStatus.FORBIDDEN
        )

        fun serverError(description: String) = OAuth2Exception(
            error = ErrorCodes.SERVER_ERROR,
            errorDescription = description,
            httpStatus = HttpStatus.INTERNAL_SERVER_ERROR
        )
    }

    /**
     * Converts this exception to a map suitable for JSON serialization.
     * Follows OAuth 2.0 error response format.
     */
    fun toErrorResponse(): Map<String, String?> = buildMap {
        put("error", error)
        errorDescription?.let { put("error_description", it) }
        errorUri?.let { put("error_uri", it) }
    }

    override fun toString(): String = buildString {
        append("OAuth2Exception(error=$error")
        errorDescription?.let { append(", description=$it") }
        append(", status=$httpStatus)")
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/model/AuthorizationCode.kt">
package com.securemonitor.oauth2.model

import jakarta.persistence.*
import java.time.Instant

/**
 * Represents an OAuth 2.0 authorization code.
 * 
 * Authorization codes are short-lived, single-use tokens that are exchanged
 * for access tokens. They are a critical part of the authorization code flow
 * and must be handled securely.
 * 
 * Security considerations:
 * - Codes are single-use and should be invalidated after exchange
 * - Codes have a short lifetime (typically 10 minutes)
 * - Codes are bound to a specific client and redirect URI
 * - PKCE parameters are stored to validate the token request
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2">RFC 6749 Section 4.1.2</a>
 */
@Entity
@Table(
    name = "oauth2_authorization_codes",
    indexes = [
        Index(name = "idx_auth_code_code", columnList = "code"),
        Index(name = "idx_auth_code_client_id", columnList = "clientId"),
        Index(name = "idx_auth_code_expires_at", columnList = "expiresAt")
    ]
)
data class AuthorizationCode(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    
    /**
     * The authorization code value.
     * This is a cryptographically random string.
     */
    @Column(unique = true, nullable = false, length = 100)
    val code: String,
    
    /**
     * The client ID that requested this authorization.
     */
    @Column(nullable = false, length = 100)
    val clientId: String,
    
    /**
     * The ID of the user who authorized the request.
     */
    @Column(nullable = false)
    val userId: Long,
    
    /**
     * The username of the user who authorized the request.
     * Stored for audit purposes.
     */
    @Column(nullable = false, length = 100)
    val username: String,
    
    /**
     * The redirect URI used in the authorization request.
     * Must be validated when exchanging the code for tokens.
     */
    @Column(nullable = false, length = 2000)
    val redirectUri: String,
    
    /**
     * Space-separated list of granted scopes.
     */
    @Column(length = 500)
    val scope: String? = null,
    
    /**
     * PKCE code challenge.
     * Required if PKCE was used in the authorization request.
     */
    @Column(length = 128)
    val codeChallenge: String? = null,
    
    /**
     * PKCE code challenge method (S256 or plain).
     */
    @Column(length = 10)
    val codeChallengeMethod: String? = null,
    
    /**
     * Nonce value for ID token (OIDC).
     * If present, must be included in the ID token.
     */
    @Column(length = 255)
    val nonce: String? = null,
    
    /**
     * When the authorization code was issued.
     */
    @Column(nullable = false)
    val issuedAt: Instant = Instant.now(),
    
    /**
     * When the authorization code expires.
     * Default is 10 minutes after issuance.
     */
    @Column(nullable = false)
    val expiresAt: Instant = Instant.now().plusSeconds(600),
    
    /**
     * Whether this code has been used.
     * Authorization codes are single-use.
     */
    @Column(nullable = false)
    var used: Boolean = false,
    
    /**
     * When the code was used (for audit purposes).
     */
    @Column
    var usedAt: Instant? = null
) {
    /**
     * Check if this authorization code has expired.
     */
    fun isExpired(): Boolean = Instant.now().isAfter(expiresAt)
    
    /**
     * Check if this authorization code is still valid.
     * A code is valid if it has not expired and has not been used.
     */
    fun isValid(): Boolean = !isExpired() && !used
    
    /**
     * Mark this authorization code as used.
     * This should be called atomically during token exchange.
     */
    fun markAsUsed() {
        used = true
        usedAt = Instant.now()
    }
    
    /**
     * Check if PKCE validation is required.
     */
    fun requiresPkce(): Boolean = codeChallenge != null
    
    /**
     * Get granted scopes as a set.
     */
    fun getScopeSet(): Set<String> =
        scope?.split(" ")?.map { it.trim() }?.filter { it.isNotEmpty() }?.toSet() ?: emptySet()
    
    companion object {
        /** Default lifetime for authorization codes in seconds */
        const val DEFAULT_LIFETIME_SECONDS = 600L // 10 minutes
        
        /** Length of the random authorization code */
        const val CODE_LENGTH = 32
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/model/OAuth2Client.kt">
package com.securemonitor.oauth2.model

import jakarta.persistence.*
import java.time.Instant

/**
 * Represents a registered OAuth 2.0 client application.
 * 
 * In OAuth 2.0, a client is an application that requests access to protected
 * resources on behalf of a resource owner (user). Clients must be registered
 * with the authorization server before they can participate in the OAuth flow.
 * 
 * There are two types of clients:
 * - **Confidential clients**: Can securely store credentials (e.g., server-side apps)
 * - **Public clients**: Cannot securely store credentials (e.g., SPAs, mobile apps)
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-2.1">RFC 6749 Section 2.1</a>
 */
@Entity
@Table(name = "oauth2_clients")
data class OAuth2Client(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    
    /**
     * Unique client identifier.
     * This is the public identifier used in OAuth requests.
     */
    @Column(unique = true, nullable = false, length = 100)
    val clientId: String,
    
    /**
     * Client secret (hashed).
     * Only present for confidential clients. Null for public clients.
     */
    @Column(length = 255)
    val clientSecretHash: String? = null,
    
    /**
     * Human-readable name of the client application.
     */
    @Column(nullable = false, length = 255)
    val clientName: String,
    
    /**
     * Description of the client application.
     */
    @Column(length = 1000)
    val description: String? = null,
    
    /**
     * Whether this is a confidential client.
     * Public clients (SPAs, mobile apps) should use PKCE instead of client secret.
     */
    @Column(nullable = false)
    val confidential: Boolean = false,
    
    /**
     * Comma-separated list of allowed redirect URIs.
     * The redirect URI in authorization requests must exactly match one of these.
     */
    @Column(nullable = false, length = 2000)
    val redirectUris: String,
    
    /**
     * Space-separated list of allowed scopes.
     */
    @Column(nullable = false, length = 500)
    val allowedScopes: String = "openid profile email",
    
    /**
     * Space-separated list of allowed grant types.
     */
    @Column(nullable = false, length = 200)
    val allowedGrantTypes: String = "authorization_code refresh_token",
    
    /**
     * Whether PKCE is required for this client.
     * Should be true for public clients.
     */
    @Column(nullable = false)
    val requirePkce: Boolean = true,
    
    /**
     * Access token lifetime in seconds.
     */
    @Column(nullable = false)
    val accessTokenLifetimeSeconds: Long = 3600, // 1 hour
    
    /**
     * Refresh token lifetime in seconds.
     */
    @Column(nullable = false)
    val refreshTokenLifetimeSeconds: Long = 86400 * 30, // 30 days
    
    /**
     * Whether the client is enabled.
     */
    @Column(nullable = false)
    val enabled: Boolean = true,
    
    /**
     * When the client was created.
     */
    @Column(nullable = false)
    val createdAt: Instant = Instant.now(),
    
    /**
     * When the client was last updated.
     */
    @Column
    val updatedAt: Instant? = null
) {
    /**
     * Get redirect URIs as a list.
     */
    fun getRedirectUriList(): List<String> = 
        redirectUris.split(",").map { it.trim() }.filter { it.isNotEmpty() }
    
    /**
     * Check if a redirect URI is allowed for this client.
     */
    fun isRedirectUriAllowed(uri: String): Boolean = 
        getRedirectUriList().contains(uri)
    
    /**
     * Get allowed scopes as a set.
     */
    fun getAllowedScopeSet(): Set<String> =
        allowedScopes.split(" ").map { it.trim() }.filter { it.isNotEmpty() }.toSet()
    
    /**
     * Check if a scope is allowed for this client.
     */
    fun isScopeAllowed(scope: String): Boolean =
        getAllowedScopeSet().contains(scope)
    
    /**
     * Check if all requested scopes are allowed.
     */
    fun areAllScopesAllowed(requestedScopes: String?): Boolean {
        if (requestedScopes.isNullOrBlank()) return true
        val requested = requestedScopes.split(" ").map { it.trim() }.filter { it.isNotEmpty() }
        val allowed = getAllowedScopeSet()
        return requested.all { it in allowed }
    }
    
    /**
     * Get allowed grant types as a set.
     */
    fun getAllowedGrantTypeSet(): Set<String> =
        allowedGrantTypes.split(" ").map { it.trim() }.filter { it.isNotEmpty() }.toSet()
    
    /**
     * Check if a grant type is allowed for this client.
     */
    fun isGrantTypeAllowed(grantType: String): Boolean =
        getAllowedGrantTypeSet().contains(grantType)
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/repository/AuthorizationCodeRepository.kt">
package com.securemonitor.oauth2.repository

import com.securemonitor.oauth2.model.AuthorizationCode
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Modifying
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import java.time.Instant
import java.util.Optional

/**
 * Repository for managing OAuth 2.0 authorization codes.
 * 
 * Authorization codes are critical security tokens and should be:
 * - Retrieved and invalidated atomically
 * - Cleaned up after expiration
 * - Audited when used
 */
@Repository
interface AuthorizationCodeRepository : JpaRepository<AuthorizationCode, Long> {
    
    /**
     * Find an authorization code by its value.
     * 
     * @param code The authorization code string
     * @return The authorization code if found
     */
    fun findByCode(code: String): Optional<AuthorizationCode>
    
    /**
     * Find an unused, non-expired authorization code.
     * This is the primary method for validating codes during token exchange.
     * 
     * @param code The authorization code string
     * @param now Current timestamp for expiration check
     * @return The valid authorization code if found
     */
    @Query("""
        SELECT ac FROM AuthorizationCode ac 
        WHERE ac.code = :code 
        AND ac.used = false 
        AND ac.expiresAt > :now
    """)
    fun findValidCode(
        @Param("code") code: String, 
        @Param("now") now: Instant
    ): Optional<AuthorizationCode>
    
    /**
     * Find all codes for a specific user.
     * Useful for revoking all codes when a user logs out.
     * 
     * @param userId The user ID
     * @return List of authorization codes for the user
     */
    fun findByUserId(userId: Long): List<AuthorizationCode>
    
    /**
     * Find all codes for a specific client.
     * Useful for revoking all codes when a client is disabled.
     * 
     * @param clientId The client ID
     * @return List of authorization codes for the client
     */
    fun findByClientId(clientId: String): List<AuthorizationCode>
    
    /**
     * Delete all expired authorization codes.
     * This should be run periodically as a cleanup job.
     * 
     * @param now Current timestamp
     * @return Number of deleted codes
     */
    @Modifying
    @Query("DELETE FROM AuthorizationCode ac WHERE ac.expiresAt < :now")
    fun deleteExpiredCodes(@Param("now") now: Instant): Int
    
    /**
     * Delete all codes for a specific user.
     * Used when revoking all sessions for a user.
     * 
     * @param userId The user ID
     * @return Number of deleted codes
     */
    @Modifying
    fun deleteByUserId(userId: Long): Int
    
    /**
     * Delete all codes for a specific client.
     * Used when disabling or deleting a client.
     * 
     * @param clientId The client ID
     * @return Number of deleted codes
     */
    @Modifying
    fun deleteByClientId(clientId: String): Int
    
    /**
     * Count unused codes for a user within a time window.
     * Used for rate limiting authorization requests.
     * 
     * @param userId The user ID
     * @param since Start of time window
     * @return Number of codes issued in the window
     */
    @Query("""
        SELECT COUNT(ac) FROM AuthorizationCode ac 
        WHERE ac.userId = :userId 
        AND ac.issuedAt > :since
    """)
    fun countRecentCodesForUser(
        @Param("userId") userId: Long, 
        @Param("since") since: Instant
    ): Long
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/repository/OAuth2ClientRepository.kt">
package com.securemonitor.oauth2.repository

import com.securemonitor.oauth2.model.OAuth2Client
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

/**
 * Repository for managing OAuth 2.0 client registrations.
 */
@Repository
interface OAuth2ClientRepository : JpaRepository<OAuth2Client, Long> {
    
    /**
     * Find a client by its client ID.
     * 
     * @param clientId The unique client identifier
     * @return The client if found
     */
    fun findByClientId(clientId: String): Optional<OAuth2Client>
    
    /**
     * Check if a client with the given ID exists.
     * 
     * @param clientId The client identifier to check
     * @return true if the client exists
     */
    fun existsByClientId(clientId: String): Boolean
    
    /**
     * Find all enabled clients.
     * 
     * @return List of enabled clients
     */
    fun findByEnabledTrue(): List<OAuth2Client>
    
    /**
     * Find a client by name.
     * 
     * @param clientName The client name
     * @return The client if found
     */
    fun findByClientName(clientName: String): Optional<OAuth2Client>
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/service/PkceService.kt">
package com.securemonitor.oauth2.service

import com.securemonitor.oauth2.exception.OAuth2Exception
import org.springframework.stereotype.Service
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.Base64

/**
 * Service for handling PKCE (Proof Key for Code Exchange) operations.
 * 
 * PKCE is a security extension to OAuth 2.0 designed to prevent authorization
 * code interception attacks. It is required for public clients (e.g., mobile apps,
 * SPAs) and recommended for all OAuth 2.0 clients.
 * 
 * The flow works as follows:
 * 1. Client generates a random `code_verifier` (43-128 characters)
 * 2. Client computes `code_challenge` = BASE64URL(SHA256(code_verifier))
 * 3. Client includes `code_challenge` and `code_challenge_method` in /authorize request
 * 4. Server stores the challenge with the authorization code
 * 5. Client includes `code_verifier` in /token request
 * 6. Server verifies that SHA256(code_verifier) matches stored challenge
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc7636">RFC 7636 - PKCE</a>
 */
@Service
class PkceService {

    companion object {
        /** Minimum length for code verifier as per RFC 7636 */
        const val CODE_VERIFIER_MIN_LENGTH = 43
        
        /** Maximum length for code verifier as per RFC 7636 */
        const val CODE_VERIFIER_MAX_LENGTH = 128
        
        /** Default length for generated code verifiers */
        const val CODE_VERIFIER_DEFAULT_LENGTH = 64
        
        /** Valid characters for code verifier (unreserved URI characters) */
        private val CODE_VERIFIER_CHARACTERS = 
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
        
        /** Pattern for validating code verifier characters */
        private val CODE_VERIFIER_PATTERN = Regex("^[A-Za-z0-9\\-._~]+$")
        
        /** Supported code challenge methods */
        val SUPPORTED_METHODS = setOf("S256", "plain")
        
        /** Recommended code challenge method */
        const val RECOMMENDED_METHOD = "S256"
    }

    private val secureRandom = SecureRandom()

    /**
     * Generates a cryptographically secure code verifier.
     * 
     * The verifier is a high-entropy cryptographic random string using the
     * unreserved characters [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~".
     * 
     * @param length The desired length (default: 64, must be 43-128)
     * @return A random code verifier string
     * @throws OAuth2Exception if length is outside valid range
     */
    fun generateCodeVerifier(length: Int = CODE_VERIFIER_DEFAULT_LENGTH): String {
        require(length in CODE_VERIFIER_MIN_LENGTH..CODE_VERIFIER_MAX_LENGTH) {
            "Code verifier length must be between $CODE_VERIFIER_MIN_LENGTH and $CODE_VERIFIER_MAX_LENGTH"
        }
        
        return buildString(length) {
            repeat(length) {
                val randomIndex = secureRandom.nextInt(CODE_VERIFIER_CHARACTERS.length)
                append(CODE_VERIFIER_CHARACTERS[randomIndex])
            }
        }
    }

    /**
     * Generates a code challenge from a code verifier.
     * 
     * For S256 method: BASE64URL(SHA256(ASCII(code_verifier)))
     * For plain method: code_challenge = code_verifier (not recommended)
     * 
     * @param codeVerifier The code verifier to transform
     * @param method The challenge method ("S256" recommended, "plain" for testing only)
     * @return The computed code challenge
     * @throws OAuth2Exception if the method is not supported
     */
    fun generateCodeChallenge(codeVerifier: String, method: String): String {
        return when (method.uppercase()) {
            "S256" -> computeS256Challenge(codeVerifier)
            "PLAIN" -> codeVerifier
            else -> throw OAuth2Exception.invalidRequest(
                "Unsupported code challenge method: $method. Supported methods: $SUPPORTED_METHODS"
            )
        }
    }

    /**
     * Verifies that a code verifier matches the stored code challenge.
     * 
     * This method uses timing-safe comparison to prevent timing attacks.
     * 
     * @param codeVerifier The code verifier from the token request
     * @param codeChallenge The code challenge stored during authorization
     * @param method The code challenge method used
     * @return true if verification succeeds, false otherwise
     */
    fun verifyCodeChallenge(codeVerifier: String, codeChallenge: String, method: String): Boolean {
        return try {
            val computedChallenge = generateCodeChallenge(codeVerifier, method)
            timingSafeEquals(computedChallenge, codeChallenge)
        } catch (e: OAuth2Exception) {
            false
        }
    }

    /**
     * Validates that a code verifier meets RFC 7636 requirements.
     * 
     * Requirements:
     * - Length: 43-128 characters
     * - Characters: [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~"
     * 
     * @param codeVerifier The code verifier to validate
     * @throws OAuth2Exception if validation fails
     */
    fun validateCodeVerifier(codeVerifier: String) {
        if (codeVerifier.length < CODE_VERIFIER_MIN_LENGTH) {
            throw OAuth2Exception.invalidRequest(
                "Code verifier must be at least $CODE_VERIFIER_MIN_LENGTH characters"
            )
        }
        
        if (codeVerifier.length > CODE_VERIFIER_MAX_LENGTH) {
            throw OAuth2Exception.invalidRequest(
                "Code verifier must not exceed $CODE_VERIFIER_MAX_LENGTH characters"
            )
        }
        
        if (!CODE_VERIFIER_PATTERN.matches(codeVerifier)) {
            throw OAuth2Exception.invalidRequest(
                "Code verifier contains invalid characters. " +
                "Allowed: A-Z, a-z, 0-9, '-', '.', '_', '~'"
            )
        }
    }

    /**
     * Computes the S256 code challenge.
     * 
     * S256: BASE64URL(SHA256(ASCII(code_verifier)))
     * Note: BASE64URL encoding omits padding ('=') as per RFC 7636.
     */
    private fun computeS256Challenge(codeVerifier: String): String {
        val bytes = codeVerifier.toByteArray(Charsets.US_ASCII)
        val digest = MessageDigest.getInstance("SHA-256").digest(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(digest)
    }

    /**
     * Performs timing-safe comparison of two strings.
     * 
     * This prevents timing attacks by ensuring the comparison takes
     * constant time regardless of where the strings differ.
     */
    private fun timingSafeEquals(a: String, b: String): Boolean {
        val aBytes = a.toByteArray(Charsets.UTF_8)
        val bBytes = b.toByteArray(Charsets.UTF_8)
        
        return MessageDigest.isEqual(aBytes, bBytes)
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/README.md">
# OAuth 2.0 / OpenID Connect Implementation

This module implements an OAuth 2.0 Authorization Server with OpenID Connect (OIDC) support.

## Overview

This implementation follows these specifications:
- [RFC 6749 - OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749)
- [RFC 7636 - PKCE](https://datatracker.ietf.org/doc/html/rfc7636)
- [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
- [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html)

## Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/oauth2/authorize` | GET | Authorization endpoint - initiates the flow |
| `/oauth2/token` | POST | Token endpoint - exchanges code for tokens |
| `/oauth2/userinfo` | GET | UserInfo endpoint - returns user claims |
| `/.well-known/openid-configuration` | GET | OIDC Discovery document |
| `/.well-known/jwks.json` | GET | JSON Web Key Set |

## Supported Flows

### Authorization Code Flow with PKCE (Recommended)

```
                                  
                                                          
  Client                                        Auth      
  (SPA)                                        Server     
                                                          
                                  
                                                    
       1. Generate code_verifier (random string)    
       2. Compute code_challenge = SHA256(verifier) 
                                                    
       3. GET /oauth2/authorize                     
          ?response_type=code                       
          &client_id=...                            
          &redirect_uri=...                         
          &code_challenge=...                       
          &code_challenge_method=S256              
          &scope=openid profile                     
          &state=...                                
     
                                                    
       4. User authenticates & consents             
                                                    
       5. 302 Redirect to redirect_uri              
          ?code=AUTHORIZATION_CODE                  
          &state=...                                
     
                                                    
       6. POST /oauth2/token                        
          grant_type=authorization_code             
          &code=AUTHORIZATION_CODE                  
          &redirect_uri=...                         
          &client_id=...                            
          &code_verifier=... (original verifier)    
     
                                                    
       7. Validate code_verifier matches challenge  
                                                    
       8. 200 OK                                    
          {                                         
            "access_token": "...",                  
            "token_type": "Bearer",                 
            "expires_in": 3600,                     
            "refresh_token": "...",                 
            "id_token": "..."                       
          }                                         
     
                                                    
```

## PKCE (Proof Key for Code Exchange)

PKCE prevents authorization code interception attacks. It's **required** for public clients (SPAs, mobile apps).

### How it works:

1. **Client generates `code_verifier`**: A cryptographically random string (43-128 chars)
2. **Client computes `code_challenge`**: `BASE64URL(SHA256(code_verifier))`
3. **Authorization request** includes `code_challenge` and `code_challenge_method=S256`
4. **Token request** includes the original `code_verifier`
5. **Server verifies** that `SHA256(code_verifier) == stored_challenge`

### Example:

```javascript
// 1. Generate code verifier
const codeVerifier = generateRandomString(64);
// e.g., "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"

// 2. Compute code challenge
const codeChallenge = base64UrlEncode(sha256(codeVerifier));
// e.g., "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"

// 3. Include in authorization request
const authUrl = `/oauth2/authorize?
  response_type=code&
  client_id=my-app&
  redirect_uri=${encodeURIComponent(redirectUri)}&
  code_challenge=${codeChallenge}&
  code_challenge_method=S256&
  scope=openid profile`;
```

## Token Types

### Access Token
- JWT format
- Used to access protected resources
- Short-lived (1 hour default)
- Contains: `sub`, `iss`, `aud`, `exp`, `iat`, `scope`, `username`

### ID Token (OIDC)
- JWT format
- Contains user identity claims
- Only issued when `openid` scope is requested
- Contains: `sub`, `iss`, `aud`, `exp`, `iat`, `auth_time`, `nonce`, `preferred_username`

### Refresh Token
- Opaque token
- Used to obtain new access tokens
- Long-lived (30 days default)
- Single-use (rotated on each use)

## Scopes

| Scope | Description | Claims |
|-------|-------------|--------|
| `openid` | Required for OIDC | `sub` |
| `profile` | Basic profile info | `preferred_username`, `name` |
| `email` | Email address | `email`, `email_verified` |

## Client Types

### Public Clients
- Cannot securely store credentials
- Examples: SPAs, mobile apps
- **Must use PKCE**
- No `client_secret`

### Confidential Clients
- Can securely store credentials
- Examples: Server-side apps
- Can use `client_secret` instead of PKCE
- Authenticate via Basic auth or POST body

## Security Considerations

1. **Always use HTTPS** in production
2. **PKCE is mandatory** for public clients
3. **State parameter** prevents CSRF attacks
4. **Authorization codes** are single-use and short-lived
5. **Redirect URIs** must exactly match registered URIs
6. **Token storage**: Store tokens securely (HttpOnly cookies or secure storage)

## Error Responses

All errors follow OAuth 2.0 error format:

```json
{
  "error": "invalid_request",
  "error_description": "Human-readable description"
}
```

### Error Codes

| Code | Description |
|------|-------------|
| `invalid_request` | Missing or invalid parameter |
| `invalid_client` | Client authentication failed |
| `invalid_grant` | Authorization code invalid or expired |
| `unauthorized_client` | Client not authorized for grant type |
| `unsupported_grant_type` | Grant type not supported |
| `invalid_scope` | Requested scope not allowed |
| `access_denied` | User denied consent |

## Testing

### Using cURL

```bash
# 1. Start authorization (in browser)
open "http://localhost:8080/oauth2/authorize?response_type=code&client_id=test-client&redirect_uri=http://localhost:3000/callback&scope=openid%20profile&state=abc123&code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&code_challenge_method=S256"

# 2. Exchange code for tokens
curl -X POST http://localhost:8080/oauth2/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=authorization_code" \
  -d "code=RECEIVED_CODE" \
  -d "redirect_uri=http://localhost:3000/callback" \
  -d "client_id=test-client" \
  -d "code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"

# 3. Get user info
curl http://localhost:8080/oauth2/userinfo \
  -H "Authorization: Bearer ACCESS_TOKEN"
```

## Configuration

```yaml
oauth2:
  issuer: http://localhost:8080
  access-token-lifetime: 3600      # seconds
  refresh-token-lifetime: 2592000  # seconds
  authorization-code-lifetime: 600 # seconds
  require-pkce: true
```

## Relevant for DF Interview

This implementation demonstrates:

1. **Deep understanding of OAuth 2.0/OIDC protocols** - Built from scratch, not using a library
2. **PKCE implementation** - Critical for modern security
3. **Token handling** - JWT generation, validation, claims
4. **Security best practices** - Input validation, timing-safe comparisons, audit logging
5. **Federation concepts** - Can act as both IdP and SP
6. **Standards compliance** - Follows RFCs and OIDC specs

### Key talking points:

- **Why PKCE?** Prevents authorization code interception in public clients
- **Why S256 over plain?** Cryptographic binding, replay protection
- **Why short-lived codes?** Minimizes window of attack
- **Why single-use codes?** Prevents replay attacks
- **Why state parameter?** CSRF protection
- **Why nonce in ID token?** Replay protection for ID tokens
</file>

<file path="backend/src/main/kotlin/com/securemonitor/repository/AuditLogRepository.kt">
// backend/src/main/kotlin/com/securemonitor/repository/AuditLogRepository.kt
package com.securemonitor.repository

import com.securemonitor.model.AuditLog
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.time.Instant

@Repository
interface AuditLogRepository : JpaRepository<AuditLog, Long> {
    fun findByUsernameOrderByTimestampDesc(username: String): List<AuditLog>
    fun findByActionOrderByTimestampDesc(action: String): List<AuditLog>
    fun findByTimestampBetweenOrderByTimestampDesc(start: Instant, end: Instant): List<AuditLog>
    fun findTop100ByOrderByTimestampDesc(): List<AuditLog>
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/repository/RoleRepository.kt">
// backend/src/main/kotlin/com/securemonitor/repository/RoleRepository.kt
package com.securemonitor.repository

import com.securemonitor.model.Role
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface RoleRepository : JpaRepository<Role, Long> {
    fun findByName(name: String): Optional<Role>
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/repository/UserRepository.kt">
// backend/src/main/kotlin/com/securemonitor/repository/UserRepository.kt 
package com.securemonitor.repository

import com.securemonitor.model.User
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface UserRepository : JpaRepository<User, Long> {
    fun findByUsername(username: String): Optional<User>
    fun findByEmail(email: String): Optional<User>
    fun existsByUsername(username: String): Boolean
    fun existsByEmail(email: String): Boolean
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/security/JwtAuthenticationFilter.kt">
// backend/src/main/kotlin/com/securemonitor/security/JwtAuthenticationFilter.kt 
package com.securemonitor.security

import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter

@Component
class JwtAuthenticationFilter(
    private val jwtService: JwtService
) : OncePerRequestFilter() {

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val authHeader = request.getHeader("Authorization")

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            val token = authHeader.substring(7)

            if (jwtService.validateToken(token)) {
                val username = jwtService.getUsername(token)
                val roles = jwtService.getRoles(token)

                val authorities = roles.map { SimpleGrantedAuthority("ROLE_$it") }

                val authentication = UsernamePasswordAuthenticationToken(
                    username,
                    null,
                    authorities
                )

                SecurityContextHolder.getContext().authentication = authentication
            }
        }

        filterChain.doFilter(request, response)
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/security/JwtService.kt">
// backend/src/main/kotlin/com/securemonitor/security/JwtService.kt
package com.securemonitor.security

import io.jsonwebtoken.Claims
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.security.Keys
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import java.util.*
import javax.crypto.SecretKey

@Service
class JwtService {

    @Value("\${jwt.secret:myDefaultSecretKeyThatIsAtLeast256BitsLong123456}")
    private lateinit var secretString: String

    @Value("\${jwt.expiration:86400000}")
    private var expiration: Long = 86400000 // 24 hours

    private val secretKey: SecretKey by lazy {
        Keys.hmacShaKeyFor(secretString.toByteArray())
    }

    fun generateToken(username: String, roles: List<String>): String {
        val now = Date()
        val expiryDate = Date(now.time + expiration)

        return Jwts.builder()
            .subject(username)
            .claim("roles", roles)
            .issuedAt(now)
            .expiration(expiryDate)
            .signWith(secretKey)
            .compact()
    }

    fun validateToken(token: String): Boolean {
        return try {
            getClaims(token)
            true
        } catch (e: Exception) {
            false
        }
    }

    fun getUsername(token: String): String {
        return getClaims(token).subject
    }

    @Suppress("UNCHECKED_CAST")
    fun getRoles(token: String): List<String> {
        return getClaims(token)["roles"] as? List<String> ?: emptyList()
    }

    private fun getClaims(token: String): Claims {
        return Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .payload
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/service/AiService.kt">
// backend/src/main/kotlin/com/securemonitor/service/AiService.kt
package com.securemonitor.service

import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import org.springframework.http.MediaType

@Service
class AiService(
    private val auditService: AuditService
) {

    @Value("\${groq.api-key:}")
    private lateinit var apiKey: String

    @Value("\${groq.model:llama-3.1-8b-instant}")
    private lateinit var model: String

    private val webClient = WebClient.builder()
        .baseUrl("https://api.groq.com/openai/v1")
        .build()

    fun chat(prompt: String, username: String): String {
        if (apiKey.isBlank()) {
            return "AI service is not configured. Please set GROQ_API_KEY."
        }

        val systemPrompt = """
            You are a security analyst AI assistant for the AI Security Monitor system.
            You help users understand security events, audit logs, and provide guidance
            on security best practices. Keep responses concise and actionable.
            Focus on IAM (Identity and Access Management) topics when relevant.
        """.trimIndent()

        val requestBody = mapOf(
            "model" to model,
            "messages" to listOf(
                mapOf("role" to "system", "content" to systemPrompt),
                mapOf("role" to "user", "content" to prompt)
            ),
            "max_tokens" to 1024,
            "temperature" to 0.7
        )

        return try {
            val response = webClient.post()
                .uri("/chat/completions")
                .header("Authorization", "Bearer $apiKey")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(Map::class.java)
                .block()

            @Suppress("UNCHECKED_CAST")
            val choices = response?.get("choices") as? List<Map<String, Any>>
            val message = choices?.firstOrNull()?.get("message") as? Map<String, Any>
            val content = message?.get("content") as? String ?: "No response from AI"

            auditService.log(
                action = "AI_CHAT",
                username = username,
                resourceType = "AI",
                details = "Prompt: ${prompt.take(100)}..."
            )

            content
        } catch (e: Exception) {
            auditService.log(
                action = "AI_CHAT_FAILED",
                username = username,
                resourceType = "AI",
                details = "Error: ${e.message}",
                success = false
            )
            "Error communicating with AI service: ${e.message}"
        }
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/service/AuditService.kt">
// backend/src/main/kotlin/com/securemonitor/service/AuditService.kt
package com.securemonitor.service

import com.securemonitor.model.AuditLog
import com.securemonitor.repository.AuditLogRepository
import org.springframework.stereotype.Service
import java.time.Instant

@Service
class AuditService(
    private val auditLogRepository: AuditLogRepository
) {

    fun log(
        action: String,
        username: String,
        resourceType: String? = null,
        resourceId: String? = null,
        ipAddress: String? = null,
        details: String? = null,
        success: Boolean = true
    ): AuditLog {
        val auditLog = AuditLog(
            action = action,
            username = username,
            resourceType = resourceType,
            resourceId = resourceId,
            ipAddress = ipAddress,
            details = details,
            success = success
        )
        return auditLogRepository.save(auditLog)
    }

    fun getRecentLogs(): List<AuditLog> {
        return auditLogRepository.findTop100ByOrderByTimestampDesc()
    }

    fun getLogsByUsername(username: String): List<AuditLog> {
        return auditLogRepository.findByUsernameOrderByTimestampDesc(username)
    }

    fun getLogsByAction(action: String): List<AuditLog> {
        return auditLogRepository.findByActionOrderByTimestampDesc(action)
    }

    fun getLogsByTimeRange(start: Instant, end: Instant): List<AuditLog> {
        return auditLogRepository.findByTimestampBetweenOrderByTimestampDesc(start, end)
    }
}
</file>

<file path="backend/src/test/kotlin/com/securemonitor/oauth2/service/AuthorizationServiceTest.kt">
package com.securemonitor.oauth2.service

import com.securemonitor.oauth2.dto.AuthorizationRequest
import com.securemonitor.oauth2.exception.OAuth2Exception
import com.securemonitor.oauth2.model.AuthorizationCode
import com.securemonitor.oauth2.model.OAuth2Client
import com.securemonitor.oauth2.repository.AuthorizationCodeRepository
import com.securemonitor.oauth2.repository.OAuth2ClientRepository
import com.securemonitor.service.AuditService
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.*
import org.assertj.core.api.Assertions.assertThat
import java.util.Optional

/**
 * Test suite for AuthorizationService.
 * 
 * Tests the authorization endpoint logic including:
 * - Request validation
 * - Client validation
 * - PKCE handling
 * - Authorization code generation
 */
@ExtendWith(MockitoExtension::class)
@DisplayName("AuthorizationService")
class AuthorizationServiceTest {

    @Mock
    private lateinit var clientRepository: OAuth2ClientRepository
    
    @Mock
    private lateinit var codeRepository: AuthorizationCodeRepository
    
    @Mock
    private lateinit var pkceService: PkceService
    
    @Mock
    private lateinit var auditService: AuditService

    private lateinit var authorizationService: AuthorizationService

    private val testClient = OAuth2Client(
        id = 1L,
        clientId = "test-client",
        clientSecretHash = null,
        clientName = "Test Client",
        confidential = false,
        redirectUris = "http://localhost:3000/callback,https://example.com/callback",
        allowedScopes = "openid profile email",
        allowedGrantTypes = "authorization_code refresh_token",
        requirePkce = true
    )

    @BeforeEach
    fun setUp() {
        authorizationService = AuthorizationService(
            clientRepository = clientRepository,
            codeRepository = codeRepository,
            pkceService = pkceService,
            auditService = auditService
        )
    }

    @Nested
    @DisplayName("validateAuthorizationRequest")
    inner class ValidateAuthorizationRequest {

        @Test
        @DisplayName("should accept valid authorization request with PKCE")
        fun shouldAcceptValidRequest() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback",
                scope = "openid profile",
                state = "abc123",
                codeChallenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
                codeChallengeMethod = "S256"
            )
            
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            
            // Should not throw
            val validatedClient = authorizationService.validateAuthorizationRequest(request)
            
            assertThat(validatedClient.clientId).isEqualTo("test-client")
        }

        @Test
        @DisplayName("should reject request with unsupported response_type")
        fun shouldRejectUnsupportedResponseType() {
            val request = AuthorizationRequest(
                responseType = "token", // implicit flow - not supported
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback"
            )
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("unsupported_response_type")
        }

        @Test
        @DisplayName("should reject request with unknown client_id")
        fun shouldRejectUnknownClient() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "unknown-client",
                redirectUri = "http://localhost:3000/callback"
            )
            
            whenever(clientRepository.findByClientId("unknown-client"))
                .thenReturn(Optional.empty())
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_client")
        }

        @Test
        @DisplayName("should reject request with mismatched redirect_uri")
        fun shouldRejectMismatchedRedirectUri() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://evil.com/callback" // not registered
            )
            
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("redirect_uri")
        }

        @Test
        @DisplayName("should reject request with invalid scope")
        fun shouldRejectInvalidScope() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback",
                scope = "openid admin" // 'admin' not allowed
            )
            
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_scope")
        }

        @Test
        @DisplayName("should reject request missing PKCE when required")
        fun shouldRejectMissingPkce() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback",
                codeChallenge = null // missing PKCE
            )
            
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("PKCE")
        }

        @Test
        @DisplayName("should reject disabled client")
        fun shouldRejectDisabledClient() {
            val disabledClient = testClient.copy(enabled = false)
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback"
            )
            
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(disabledClient))
            
            val exception = assertThrows<OAuth2Exception> {
                authorizationService.validateAuthorizationRequest(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_client")
        }
    }

    @Nested
    @DisplayName("createAuthorizationCode")
    inner class CreateAuthorizationCode {

        @Test
        @DisplayName("should create authorization code with all parameters")
        fun shouldCreateCodeWithAllParameters() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback",
                scope = "openid profile",
                state = "abc123",
                codeChallenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
                codeChallengeMethod = "S256",
                nonce = "nonce123"
            )
            
            whenever(codeRepository.save(any<AuthorizationCode>()))
                .thenAnswer { it.arguments[0] as AuthorizationCode }
            
            val code = authorizationService.createAuthorizationCode(
                client = testClient,
                request = request,
                userId = 42L,
                username = "testuser"
            )
            
            assertThat(code.code).isNotBlank()
            assertThat(code.code.length).isGreaterThanOrEqualTo(32)
            assertThat(code.clientId).isEqualTo("test-client")
            assertThat(code.userId).isEqualTo(42L)
            assertThat(code.username).isEqualTo("testuser")
            assertThat(code.redirectUri).isEqualTo("http://localhost:3000/callback")
            assertThat(code.scope).isEqualTo("openid profile")
            assertThat(code.codeChallenge).isEqualTo("E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM")
            assertThat(code.codeChallengeMethod).isEqualTo("S256")
            assertThat(code.nonce).isEqualTo("nonce123")
            assertThat(code.used).isFalse()
            
            verify(codeRepository).save(any())
            verify(auditService).log(
                action = eq("OAUTH2_CODE_ISSUED"),
                username = eq("testuser"),
                resourceType = eq("OAUTH2_CLIENT"),
                resourceId = eq("test-client"),
                ipAddress = anyOrNull(),
                details = anyOrNull(),
                success = eq(true)
            )
        }

        @Test
        @DisplayName("should generate unique codes")
        fun shouldGenerateUniqueCodes() {
            val request = AuthorizationRequest(
                responseType = "code",
                clientId = "test-client",
                redirectUri = "http://localhost:3000/callback"
            )
            
            whenever(codeRepository.save(any<AuthorizationCode>()))
                .thenAnswer { it.arguments[0] as AuthorizationCode }
            
            val codes = (1..100).map {
                authorizationService.createAuthorizationCode(
                    client = testClient,
                    request = request,
                    userId = 1L,
                    username = "user"
                ).code
            }.toSet()
            
            assertThat(codes).hasSize(100)
        }
    }

    @Nested
    @DisplayName("buildAuthorizationRedirect")
    inner class BuildAuthorizationRedirect {

        @Test
        @DisplayName("should build redirect URI with code and state")
        fun shouldBuildRedirectWithCodeAndState() {
            val redirectUri = authorizationService.buildAuthorizationRedirect(
                baseRedirectUri = "http://localhost:3000/callback",
                code = "auth-code-123",
                state = "state-abc"
            )
            
            assertThat(redirectUri).isEqualTo(
                "http://localhost:3000/callback?code=auth-code-123&state=state-abc"
            )
        }

        @Test
        @DisplayName("should build redirect URI without state when not provided")
        fun shouldBuildRedirectWithoutState() {
            val redirectUri = authorizationService.buildAuthorizationRedirect(
                baseRedirectUri = "http://localhost:3000/callback",
                code = "auth-code-123",
                state = null
            )
            
            assertThat(redirectUri).isEqualTo(
                "http://localhost:3000/callback?code=auth-code-123"
            )
        }

        @Test
        @DisplayName("should preserve existing query parameters")
        fun shouldPreserveExistingQueryParams() {
            val redirectUri = authorizationService.buildAuthorizationRedirect(
                baseRedirectUri = "http://localhost:3000/callback?existing=param",
                code = "auth-code-123",
                state = "state-abc"
            )
            
            assertThat(redirectUri).contains("existing=param")
            assertThat(redirectUri).contains("code=auth-code-123")
            assertThat(redirectUri).contains("state=state-abc")
        }
    }

    @Nested
    @DisplayName("buildErrorRedirect")
    inner class BuildErrorRedirect {

        @Test
        @DisplayName("should build error redirect with all parameters")
        fun shouldBuildErrorRedirect() {
            val redirectUri = authorizationService.buildErrorRedirect(
                baseRedirectUri = "http://localhost:3000/callback",
                error = "access_denied",
                errorDescription = "User denied consent",
                state = "state-abc"
            )
            
            assertThat(redirectUri).contains("error=access_denied")
            assertThat(redirectUri).contains("error_description=User")
            assertThat(redirectUri).contains("state=state-abc")
        }
    }
}
</file>

<file path="backend/src/test/kotlin/com/securemonitor/oauth2/service/PkceServiceTest.kt">
package com.securemonitor.oauth2.service

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.assertThrows
import org.assertj.core.api.Assertions.assertThat
import com.securemonitor.oauth2.exception.OAuth2Exception

/**
 * Test suite for PKCE (Proof Key for Code Exchange) service.
 * 
 * PKCE is a security extension to OAuth 2.0 that prevents authorization code
 * interception attacks. It's required for public clients and recommended for
 * all OAuth 2.0 clients.
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc7636">RFC 7636</a>
 */
@DisplayName("PkceService")
class PkceServiceTest {

    private lateinit var pkceService: PkceService

    @BeforeEach
    fun setUp() {
        pkceService = PkceService()
    }

    @Nested
    @DisplayName("generateCodeVerifier")
    inner class GenerateCodeVerifier {

        @Test
        @DisplayName("should generate a code verifier with valid length (43-128 characters)")
        fun shouldGenerateValidLength() {
            val verifier = pkceService.generateCodeVerifier()
            
            assertThat(verifier.length).isBetween(43, 128)
        }

        @Test
        @DisplayName("should generate a code verifier using only valid characters (A-Z, a-z, 0-9, -._~)")
        fun shouldUseOnlyValidCharacters() {
            val verifier = pkceService.generateCodeVerifier()
            val validPattern = Regex("^[A-Za-z0-9\\-._~]+$")
            
            assertThat(verifier).matches(validPattern.toPattern())
        }

        @Test
        @DisplayName("should generate unique verifiers on each call")
        fun shouldGenerateUniqueVerifiers() {
            val verifiers = (1..100).map { pkceService.generateCodeVerifier() }.toSet()
            
            assertThat(verifiers).hasSize(100)
        }
    }

    @Nested
    @DisplayName("generateCodeChallenge")
    inner class GenerateCodeChallenge {

        @Test
        @DisplayName("should generate S256 challenge from verifier")
        fun shouldGenerateS256Challenge() {
            // Known test vector from RFC 7636 Appendix B
            val verifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            val expectedChallenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
            
            val challenge = pkceService.generateCodeChallenge(verifier, "S256")
            
            assertThat(challenge).isEqualTo(expectedChallenge)
        }

        @Test
        @DisplayName("should support plain method (for testing only)")
        fun shouldSupportPlainMethod() {
            val verifier = "test-verifier-string"
            
            val challenge = pkceService.generateCodeChallenge(verifier, "plain")
            
            assertThat(challenge).isEqualTo(verifier)
        }

        @Test
        @DisplayName("should throw exception for unsupported method")
        fun shouldThrowForUnsupportedMethod() {
            val verifier = "test-verifier"
            
            val exception = assertThrows<OAuth2Exception> {
                pkceService.generateCodeChallenge(verifier, "MD5")
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("Unsupported code challenge method")
        }
    }

    @Nested
    @DisplayName("verifyCodeChallenge")
    inner class VerifyCodeChallenge {

        @Test
        @DisplayName("should return true when S256 challenge matches verifier")
        fun shouldVerifyValidS256Challenge() {
            val verifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            val challenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
            
            val result = pkceService.verifyCodeChallenge(verifier, challenge, "S256")
            
            assertThat(result).isTrue()
        }

        @Test
        @DisplayName("should return false when S256 challenge does not match")
        fun shouldRejectInvalidS256Challenge() {
            val verifier = "wrong-verifier"
            val challenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
            
            val result = pkceService.verifyCodeChallenge(verifier, challenge, "S256")
            
            assertThat(result).isFalse()
        }

        @Test
        @DisplayName("should return true when plain challenge matches verifier")
        fun shouldVerifyValidPlainChallenge() {
            val verifier = "my-plain-verifier"
            val challenge = "my-plain-verifier"
            
            val result = pkceService.verifyCodeChallenge(verifier, challenge, "plain")
            
            assertThat(result).isTrue()
        }

        @Test
        @DisplayName("should use timing-safe comparison to prevent timing attacks")
        fun shouldUseTimingSafeComparison() {
            // This test verifies the behavior, actual timing-safe implementation
            // is verified through code review
            val verifier = pkceService.generateCodeVerifier()
            val challenge = pkceService.generateCodeChallenge(verifier, "S256")
            
            val result = pkceService.verifyCodeChallenge(verifier, challenge, "S256")
            
            assertThat(result).isTrue()
        }
    }

    @Nested
    @DisplayName("validateCodeVerifier")
    inner class ValidateCodeVerifier {

        @Test
        @DisplayName("should accept valid code verifier")
        fun shouldAcceptValidVerifier() {
            val verifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            
            // Should not throw
            pkceService.validateCodeVerifier(verifier)
        }

        @Test
        @DisplayName("should reject code verifier shorter than 43 characters")
        fun shouldRejectTooShortVerifier() {
            val verifier = "too-short"
            
            val exception = assertThrows<OAuth2Exception> {
                pkceService.validateCodeVerifier(verifier)
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("43")
        }

        @Test
        @DisplayName("should reject code verifier longer than 128 characters")
        fun shouldRejectTooLongVerifier() {
            val verifier = "a".repeat(129)
            
            val exception = assertThrows<OAuth2Exception> {
                pkceService.validateCodeVerifier(verifier)
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("128")
        }

        @Test
        @DisplayName("should reject code verifier with invalid characters")
        fun shouldRejectInvalidCharacters() {
            val verifier = "valid-start-but-has-invalid-char-!" + "a".repeat(30)
            
            val exception = assertThrows<OAuth2Exception> {
                pkceService.validateCodeVerifier(verifier)
            }
            
            assertThat(exception.error).isEqualTo("invalid_request")
            assertThat(exception.errorDescription).contains("invalid characters")
        }
    }
}
</file>

<file path="backend/src/test/kotlin/com/securemonitor/oauth2/service/TokenServiceTest.kt">
package com.securemonitor.oauth2.service

import com.securemonitor.oauth2.dto.TokenRequest
import com.securemonitor.oauth2.exception.OAuth2Exception
import com.securemonitor.oauth2.model.AuthorizationCode
import com.securemonitor.oauth2.model.OAuth2Client
import com.securemonitor.oauth2.repository.AuthorizationCodeRepository
import com.securemonitor.oauth2.repository.OAuth2ClientRepository
import com.securemonitor.service.AuditService
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.extension.ExtendWith
import org.mockito.Mock
import org.mockito.junit.jupiter.MockitoExtension
import org.mockito.kotlin.*
import org.assertj.core.api.Assertions.assertThat
import java.time.Instant
import java.util.Optional

/**
 * Test suite for TokenService.
 * 
 * Tests the token endpoint logic including:
 * - Authorization code exchange
 * - PKCE verification
 * - Token generation
 * - Refresh token flow
 */
@ExtendWith(MockitoExtension::class)
@DisplayName("TokenService")
class TokenServiceTest {

    @Mock
    private lateinit var clientRepository: OAuth2ClientRepository
    
    @Mock
    private lateinit var codeRepository: AuthorizationCodeRepository
    
    @Mock
    private lateinit var pkceService: PkceService
    
    @Mock
    private lateinit var auditService: AuditService

    private lateinit var tokenService: TokenService

    private val testClient = OAuth2Client(
        id = 1L,
        clientId = "test-client",
        clientSecretHash = null,
        clientName = "Test Client",
        confidential = false,
        redirectUris = "http://localhost:3000/callback",
        allowedScopes = "openid profile email",
        allowedGrantTypes = "authorization_code refresh_token",
        requirePkce = true,
        accessTokenLifetimeSeconds = 3600,
        refreshTokenLifetimeSeconds = 86400
    )

    private val testAuthCode = AuthorizationCode(
        id = 1L,
        code = "valid-auth-code",
        clientId = "test-client",
        userId = 42L,
        username = "testuser",
        redirectUri = "http://localhost:3000/callback",
        scope = "openid profile",
        codeChallenge = "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
        codeChallengeMethod = "S256",
        nonce = "nonce123",
        issuedAt = Instant.now(),
        expiresAt = Instant.now().plusSeconds(600),
        used = false
    )

    @BeforeEach
    fun setUp() {
        tokenService = TokenService(
            clientRepository = clientRepository,
            codeRepository = codeRepository,
            pkceService = pkceService,
            auditService = auditService,
            issuer = "http://localhost:8080",
            accessTokenLifetimeSeconds = 3600,
            refreshTokenLifetimeSeconds = 86400
        )
    }

    @Nested
    @DisplayName("exchangeAuthorizationCode")
    inner class ExchangeAuthorizationCode {

        @Test
        @DisplayName("should exchange valid authorization code for tokens")
        fun shouldExchangeValidCode() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "valid-auth-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "test-client",
                codeVerifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            )
            
            whenever(codeRepository.findValidCode(eq("valid-auth-code"), any()))
                .thenReturn(Optional.of(testAuthCode))
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            whenever(pkceService.verifyCodeChallenge(
                eq("dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"),
                eq("E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"),
                eq("S256")
            )).thenReturn(true)
            whenever(codeRepository.save(any<AuthorizationCode>()))
                .thenAnswer { it.arguments[0] }
            
            val response = tokenService.exchangeAuthorizationCode(request)
            
            assertThat(response.accessToken).isNotBlank()
            assertThat(response.tokenType).isEqualTo("Bearer")
            assertThat(response.expiresIn).isEqualTo(3600)
            assertThat(response.refreshToken).isNotBlank()
            assertThat(response.scope).isEqualTo("openid profile")
            
            // Verify code was marked as used
            verify(codeRepository).save(argThat { used })
        }

        @Test
        @DisplayName("should reject expired authorization code")
        fun shouldRejectExpiredCode() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "expired-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "test-client"
            )
            
            whenever(codeRepository.findValidCode(eq("expired-code"), any()))
                .thenReturn(Optional.empty())
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
        }

        @Test
        @DisplayName("should reject already used authorization code")
        fun shouldRejectUsedCode() {
            val usedCode = testAuthCode.copy(used = true)
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "used-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "test-client"
            )
            
            // findValidCode already excludes used codes
            whenever(codeRepository.findValidCode(eq("used-code"), any()))
                .thenReturn(Optional.empty())
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
        }

        @Test
        @DisplayName("should reject mismatched redirect_uri")
        fun shouldRejectMismatchedRedirectUri() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "valid-auth-code",
                redirectUri = "http://different.com/callback", // different from code
                clientId = "test-client",
                codeVerifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            )
            
            whenever(codeRepository.findValidCode(eq("valid-auth-code"), any()))
                .thenReturn(Optional.of(testAuthCode))
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
            assertThat(exception.errorDescription).contains("redirect_uri")
        }

        @Test
        @DisplayName("should reject mismatched client_id")
        fun shouldRejectMismatchedClientId() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "valid-auth-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "different-client", // different from code
                codeVerifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
            )
            
            whenever(codeRepository.findValidCode(eq("valid-auth-code"), any()))
                .thenReturn(Optional.of(testAuthCode))
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
            assertThat(exception.errorDescription).contains("client")
        }

        @Test
        @DisplayName("should reject invalid PKCE verifier")
        fun shouldRejectInvalidPkceVerifier() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "valid-auth-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "test-client",
                codeVerifier = "wrong-verifier"
            )
            
            whenever(codeRepository.findValidCode(eq("valid-auth-code"), any()))
                .thenReturn(Optional.of(testAuthCode))
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            whenever(pkceService.verifyCodeChallenge(
                eq("wrong-verifier"),
                eq("E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"),
                eq("S256")
            )).thenReturn(false)
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
            assertThat(exception.errorDescription).contains("PKCE")
        }

        @Test
        @DisplayName("should reject missing PKCE verifier when required")
        fun shouldRejectMissingPkceVerifier() {
            val request = TokenRequest(
                grantType = "authorization_code",
                code = "valid-auth-code",
                redirectUri = "http://localhost:3000/callback",
                clientId = "test-client",
                codeVerifier = null // missing
            )
            
            whenever(codeRepository.findValidCode(eq("valid-auth-code"), any()))
                .thenReturn(Optional.of(testAuthCode))
            whenever(clientRepository.findByClientId("test-client"))
                .thenReturn(Optional.of(testClient))
            
            val exception = assertThrows<OAuth2Exception> {
                tokenService.exchangeAuthorizationCode(request)
            }
            
            assertThat(exception.error).isEqualTo("invalid_grant")
            assertThat(exception.errorDescription).contains("code_verifier")
        }
    }

    @Nested
    @DisplayName("validateGrantType")
    inner class ValidateGrantType {

        @Test
        @DisplayName("should accept supported grant types")
        fun shouldAcceptSupportedGrantTypes() {
            // Should not throw
            tokenService.validateGrantType("authorization_code")
            tokenService.validateGrantType("refresh_token")
        }

        @Test
        @DisplayName("should reject unsupported grant types")
        fun shouldRejectUnsupportedGrantTypes() {
            val exception = assertThrows<OAuth2Exception> {
                tokenService.validateGrantType("password")
            }
            
            assertThat(exception.error).isEqualTo("unsupported_grant_type")
        }
    }
}
</file>

<file path="backend/src/test/kotlin/com/securemonitor/BackendApplicationTests.kt">
package com.securemonitor

import org.junit.jupiter.api.Test
import org.springframework.boot.test.context.SpringBootTest

@SpringBootTest
class BackendApplicationTests {

	@Test
	fun contextLoads() {
	}

}
</file>

<file path="backend/.gitattributes">
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary
</file>

<file path="backend/.gitignore">
HELP.md
.gradle
build/
!gradle/wrapper/gradle-wrapper.jar
!**/src/main/**/build/
!**/src/test/**/build/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache
bin/
!**/src/main/**/bin/
!**/src/test/**/bin/

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
out/
!**/src/main/**/out/
!**/src/test/**/out/

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/

### VS Code ###
.vscode/

### Kotlin ###
.kotlin
.env
</file>

<file path="backend/Dockerfile">
# backend/Dockerfile

# Build stage
FROM gradle:8.14-jdk21 AS build
WORKDIR /app
COPY . .
RUN gradle build -x test --no-daemon

# Runtime stage
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app

# Create non-root user for security
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Copy the built jar
COPY --from=build /app/build/libs/backend-0.0.1-SNAPSHOT.jar app.jar

# Set ownership
RUN chown -R appuser:appgroup /app
USER appuser

# Expose port
EXPOSE 8080

# Run the application
ENTRYPOINT ["java", "-jar", "app.jar"]
</file>

<file path="backend/gradlew">
#!/bin/sh

#
# Copyright  2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions $var, ${var}, ${var:-default}, ${var+SET},
#           ${var#prefix}, ${var%suffix}, and $( cmd );
#         * compound commands having a testable exit status, especially case;
#         * various built-in commands including command, set, and ulimit.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="backend/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="backend/settings.gradle.kts">
rootProject.name = "backend"
</file>

<file path="docker/docker-compose.yml">
## docker/docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: securemonitor-db
    environment:
      POSTGRES_DB: securemonitor
      POSTGRES_USER: securemonitor
      POSTGRES_PASSWORD: localdev123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U securemonitor"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/components/admin/AdminPanel.tsx">
// frontend/src/components/admin/AdminPanel.tsx 
import { useState, useEffect } from 'react';
import { adminService } from '../../services/api';
import { Button } from '../ui/Button';
import type { UserResponse } from '../../types';

export function AdminPanel() {
  const [users, setUsers] = useState<UserResponse[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchUsers = async () => {
    try {
      const data = await adminService.getAllUsers();
      setUsers(data);
      setError('');
    } catch (err) {
      setError('Failed to load users. You may not have admin access.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  const handleAddRole = async (userId: number, roleName: string) => {
    try {
      await adminService.addRoleToUser(userId, roleName);
      fetchUsers();
    } catch (err) {
      setError('Failed to add role');
    }
  };

  const handleRemoveRole = async (userId: number, roleName: string) => {
    try {
      await adminService.removeRoleFromUser(userId, roleName);
      fetchUsers();
    } catch (err) {
      setError('Failed to remove role');
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };

  if (isLoading) {
    return (
      <div className="bg-white rounded-xl shadow-sm p-6">
        <div className="flex justify-center py-8">
          <svg className="animate-spin h-8 w-8 text-blue-600" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
          </svg>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-xl shadow-sm p-6">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">Admin Panel</h2>
        <div className="p-4 bg-red-50 rounded-lg">
          <p className="text-red-600">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-xl shadow-sm p-6">
      <h2 className="text-lg font-semibold text-gray-900 mb-4">Admin Panel - User Management</h2>
      
      <div className="overflow-x-auto">
        {/* Mobile View */}
        <div className="sm:hidden space-y-4">
          {users.map((user) => (
            <div key={user.id} className="border rounded-lg p-4 space-y-3">
              <div>
                <p className="font-medium text-gray-900">{user.username}</p>
                <p className="text-sm text-gray-500">{user.email}</p>
              </div>
              <div className="flex flex-wrap gap-2">
                {user.roles.map((role) => (
                  <span
                    key={role}
                    className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium"
                  >
                    {role}
                    {role !== 'USER' && (
                      <button
                        onClick={() => handleRemoveRole(user.id, role)}
                        className="text-blue-600 hover:text-red-600"
                      >
                        
                      </button>
                    )}
                  </span>
                ))}
              </div>
              {!user.roles.includes('ADMIN') && (
                <Button
                  variant="secondary"
                  onClick={() => handleAddRole(user.id, 'ADMIN')}
                  className="!w-auto !py-1 text-sm"
                >
                  Make Admin
                </Button>
              )}
            </div>
          ))}
        </div>

        {/* Desktop View */}
        <table className="hidden sm:table w-full">
          <thead>
            <tr className="border-b">
              <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">User</th>
              <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Email</th>
              <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Roles</th>
              <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Created</th>
              <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Actions</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr key={user.id} className="border-b hover:bg-gray-50">
                <td className="py-3 px-4 text-sm font-medium text-gray-900">{user.username}</td>
                <td className="py-3 px-4 text-sm text-gray-600">{user.email}</td>
                <td className="py-3 px-4">
                  <div className="flex flex-wrap gap-1">
                    {user.roles.map((role) => (
                      <span
                        key={role}
                        className="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium"
                      >
                        {role}
                        {role !== 'USER' && (
                          <button
                            onClick={() => handleRemoveRole(user.id, role)}
                            className="text-blue-600 hover:text-red-600"
                          >
                            
                          </button>
                        )}
                      </span>
                    ))}
                  </div>
                </td>
                <td className="py-3 px-4 text-sm text-gray-600">{formatDate(user.createdAt)}</td>
                <td className="py-3 px-4">
                  {!user.roles.includes('ADMIN') && (
                    <Button
                      variant="secondary"
                      onClick={() => handleAddRole(user.id, 'ADMIN')}
                      className="!w-auto !py-1 text-sm"
                    >
                      Make Admin
                    </Button>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/auth/LoginForm.tsx">
// frontend/src/components/auth/LoginForm.tsx
import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '../ui/Button';
import { Input } from '../ui/Input';

interface LoginFormProps {
  onSubmit: (username: string, password: string) => Promise<void>;
  onSwitchToRegister: () => void;
}

export function LoginForm({ onSubmit, onSwitchToRegister }: LoginFormProps) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await onSubmit(username, password);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="text-center">
        <h1 className="text-2xl font-bold text-gray-900">Welcome Back</h1>
        <p className="mt-2 text-gray-600">Sign in to your account</p>
      </div>

      {error && (
        <div className="p-3 rounded-lg bg-red-50 border border-red-200" role="alert">
          <p className="text-sm text-red-600">{error}</p>
        </div>
      )}

      <div className="space-y-4">
        <Input
          label="Username"
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
          autoComplete="username"
          placeholder="Enter your username"
        />

        <Input
          label="Password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          autoComplete="current-password"
          placeholder="Enter your password"
        />
      </div>

      <Button type="submit" isLoading={isLoading}>
        Sign In
      </Button>

      <p className="text-center text-sm text-gray-600">
        Don't have an account?{' '}
        <button
          type="button"
          onClick={onSwitchToRegister}
          className="text-blue-600 hover:text-blue-800 font-medium"
        >
          Register here
        </button>
      </p>
    </form>
  );
}
</file>

<file path="frontend/src/components/auth/RegisterForm.tsx">
// frontend/src/components/auth/RegisterForm.tsx
import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '../ui/Button';
import { Input } from '../ui/Input';

interface RegisterFormProps {
  onSubmit: (username: string, email: string, password: string) => Promise<void>;
  onSwitchToLogin: () => void;
}

export function RegisterForm({ onSubmit, onSwitchToLogin }: RegisterFormProps) {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setError('');

    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    if (password.length < 8) {
      setError('Password must be at least 8 characters');
      return;
    }

    setIsLoading(true);

    try {
      await onSubmit(username, email, password);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Registration failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="text-center">
        <h1 className="text-2xl font-bold text-gray-900">Create Account</h1>
        <p className="mt-2 text-gray-600">Register for a new account</p>
      </div>

      {error && (
        <div className="p-3 rounded-lg bg-red-50 border border-red-200" role="alert">
          <p className="text-sm text-red-600">{error}</p>
        </div>
      )}

      <div className="space-y-4">
        <Input
          label="Username"
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
          autoComplete="username"
          placeholder="Choose a username"
        />

        <Input
          label="Email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          autoComplete="email"
          placeholder="Enter your email"
        />

        <Input
          label="Password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          autoComplete="new-password"
          placeholder="Choose a password (min. 8 characters)"
        />

        <Input
          label="Confirm Password"
          type="password"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
          autoComplete="new-password"
          placeholder="Confirm your password"
        />
      </div>

      <Button type="submit" isLoading={isLoading}>
        Create Account
      </Button>

      <p className="text-center text-sm text-gray-600">
        Already have an account?{' '}
        <button
          type="button"
          onClick={onSwitchToLogin}
          className="text-blue-600 hover:text-blue-800 font-medium"
        >
          Sign in here
        </button>
      </p>
    </form>
  );
}
</file>

<file path="frontend/src/components/chat/AiChat.tsx">
// frontend/src/components/chat/AiChat.tsx
import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '../ui/Button';
import { aiService } from '../../services/api';

interface Message {
  id: number;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

export function AiChat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      id: Date.now(),
      role: 'user',
      content: input.trim(),
      timestamp: new Date().toISOString(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await aiService.chat(userMessage.content);
      const assistantMessage: Message = {
        id: Date.now() + 1,
        role: 'assistant',
        content: response.response,
        timestamp: response.timestamp,
      };
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      const errorMessage: Message = {
        id: Date.now() + 1,
        role: 'assistant',
        content: 'Sorry, I encountered an error. Please try again.',
        timestamp: new Date().toISOString(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="bg-white rounded-xl shadow-sm flex flex-col h-[500px]">
      <div className="p-4 border-b">
        <h2 className="text-lg font-semibold text-gray-900">AI Security Assistant</h2>
        <p className="text-sm text-gray-500">Ask questions about security and IAM</p>
      </div>

      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">
            <p>No messages yet.</p>
            <p className="text-sm mt-2">Try asking about security best practices or audit logs.</p>
          </div>
        ) : (
          messages.map(message => (
            <div
              key={message.id}
              className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`max-w-[80%] rounded-lg px-4 py-2 ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-100 text-gray-900'
                }`}
              >
                <p className="whitespace-pre-wrap">{message.content}</p>
              </div>
            </div>
          ))
        )}
        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-gray-100 rounded-lg px-4 py-2">
              <div className="flex items-center gap-2">
                <svg className="animate-spin h-4 w-4 text-gray-600" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
                </svg>
                <span className="text-gray-600">Thinking...</span>
              </div>
            </div>
          </div>
        )}
      </div>

      <form onSubmit={handleSubmit} className="p-4 border-t">
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask a security question..."
            className="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[44px]"
            disabled={isLoading}
          />
          <Button type="submit" isLoading={isLoading} className="!w-auto px-6">
            Send
          </Button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="frontend/src/components/ui/Button.tsx">
// frontend/src/components/ui/Button.tsx
import type { ButtonHTMLAttributes, ReactNode } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  isLoading?: boolean;
}

export function Button({ 
  children, 
  variant = 'primary', 
  isLoading = false,
  disabled,
  className = '',
  ...props 
}: ButtonProps) {
  const baseStyles = 'w-full px-4 py-3 rounded-lg font-medium transition-colors duration-200 min-h-[44px] disabled:opacity-50 disabled:cursor-not-allowed';
  
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 active:bg-gray-400',
    danger: 'bg-red-600 text-white hover:bg-red-700 active:bg-red-800',
  };

  return (
    <button
      className={`${baseStyles} ${variants[variant]} ${className}`}
      disabled={disabled || isLoading}
      {...props}
    >
      {isLoading ? (
        <span className="flex items-center justify-center gap-2">
          <svg className="animate-spin h-5 w-5\" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
          </svg>
          Loading...
        </span>
      ) : children}
    </button>
  );
}
</file>

<file path="frontend/src/components/ui/Input.tsx">
// frontend/src/components/ui/Input.tsx
import type { InputHTMLAttributes } from 'react';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label: string;
  error?: string;
}

export function Input({ 
  label, 
  error, 
  id,
  className = '',
  ...props 
}: InputProps) {
  const inputId = id || label.toLowerCase().replace(/\s+/g, '-');

  return (
    <div className="space-y-1">
      <label 
        htmlFor={inputId}
        className="block text-sm font-medium text-gray-700"
      >
        {label}
      </label>
      <input
        id={inputId}
        className={`
          w-full px-4 py-3 rounded-lg border transition-colors duration-200
          min-h-[44px] text-base
          ${error 
            ? 'border-red-500 focus:ring-red-500 focus:border-red-500' 
            : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500'
          }
          focus:outline-none focus:ring-2
          ${className}
        `}
        {...props}
      />
      {error && (
        <p className="text-sm text-red-600" role="alert">
          {error}
        </p>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/hooks/useAuth.ts">
// frontend/src/hooks/useAuth.ts 
import { useState, useEffect, useCallback } from 'react';
import type { AuthResponse, LoginRequest, RegisterRequest } from '../types';
import { authService } from '../services/api';

interface AuthState {
  isAuthenticated: boolean;
  username: string | null;
  roles: string[];
  isLoading: boolean;
}

export function useAuth() {
  const [state, setState] = useState<AuthState>({
    isAuthenticated: false,
    username: null,
    roles: [],
    isLoading: true,
  });

  useEffect(() => {
    const token = authService.getToken();
    if (token) {
      try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        setState({
          isAuthenticated: true,
          username: payload.sub,
          roles: payload.roles || [],
          isLoading: false,
        });
      } catch {
        authService.logout();
        setState({
          isAuthenticated: false,
          username: null,
          roles: [],
          isLoading: false,
        });
      }
    } else {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, []);

  const login = useCallback(async (data: LoginRequest): Promise<AuthResponse> => {
    const response = await authService.login(data);
    setState({
      isAuthenticated: true,
      username: response.username,
      roles: response.roles,
      isLoading: false,
    });
    return response;
  }, []);

  const register = useCallback(async (data: RegisterRequest): Promise<AuthResponse> => {
    const response = await authService.register(data);
    setState({
      isAuthenticated: true,
      username: response.username,
      roles: response.roles,
      isLoading: false,
    });
    return response;
  }, []);

  const logout = useCallback(() => {
    authService.logout();
    setState({
      isAuthenticated: false,
      username: null,
      roles: [],
      isLoading: false,
    });
  }, []);

  const hasRole = useCallback((role: string) => {
    return state.roles.includes(role);
  }, [state.roles]);

  return {
    ...state,
    login,
    register,
    logout,
    hasRole,
  };
}
</file>

<file path="frontend/src/pages/LoginPage.tsx">
// frontend/src/pages/LoginPage.tsx
import { useState } from 'react';
import { LoginForm } from '../components/auth/LoginForm';
import { RegisterForm } from '../components/auth/RegisterForm';
import { useAuth } from '../hooks/useAuth';

interface LoginPageProps {
  onSuccess: () => void;
}

export function LoginPage({ onSuccess }: LoginPageProps) {
  const [isLogin, setIsLogin] = useState(true);
  const { login, register } = useAuth();

  const handleLogin = async (username: string, password: string) => {
    await login({ username, password });
    onSuccess();
  };

  const handleRegister = async (username: string, email: string, password: string) => {
    await register({ username, email, password });
    onSuccess();
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center px-4 py-12">
      <div className="w-full max-w-md mx-auto">
        <div className="bg-white rounded-xl shadow-lg p-6 sm:p-8">
          {isLogin ? (
            <LoginForm
              onSubmit={handleLogin}
              onSwitchToRegister={() => setIsLogin(false)}
            />
          ) : (
            <RegisterForm
              onSubmit={handleRegister}
              onSwitchToLogin={() => setIsLogin(true)}
            />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="frontend/src/App.tsx">
// frontend/src/App.tsx
import { useState, useEffect } from 'react';
import { LoginPage } from './pages/LoginPage';
import { DashboardPage } from './pages/DashboardPage';
import { authService } from './services/api';

function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    setIsAuthenticated(authService.isAuthenticated());
    setIsLoading(false);
  }, []);

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <svg className="animate-spin h-10 w-10 text-blue-600" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
        </svg>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginPage onSuccess={() => setIsAuthenticated(true)} />;
  }

  return <DashboardPage onLogout={() => setIsAuthenticated(false)} />;
}

export default App;
</file>

<file path="frontend/src/index.css">
/* frontend/src/index.css */
@import "tailwindcss";
</file>

<file path="frontend/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "axios": "^1.13.2",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.12.0",
    "tailwindcss": "^4.1.18"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}
</file>

<file path="frontend/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vite.config.ts">
// frontend/vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [react(), tailwindcss()],
})
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/_helpers.tpl">
{{/*
Expand the name of the chart.
*/}}
{{- define "ai-security-monitor.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
*/}}
{{- define "ai-security-monitor.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "ai-security-monitor.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "ai-security-monitor.labels" -}}
helm.sh/chart: {{ include "ai-security-monitor.chart" . }}
{{ include "ai-security-monitor.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "ai-security-monitor.selectorLabels" -}}
app.kubernetes.io/name: {{ include "ai-security-monitor.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "ai-security-monitor.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "ai-security-monitor.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}

{{/*
PostgreSQL host
*/}}
{{- define "ai-security-monitor.postgresql.host" -}}
{{- if .Values.postgresql.enabled }}
{{- printf "%s-postgresql" .Release.Name }}
{{- else }}
{{- .Values.externalDatabase.host }}
{{- end }}
{{- end }}
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/configmap.yaml">
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "ai-security-monitor.fullname" . }}-config
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
data:
  PGHOST: {{ include "ai-security-monitor.postgresql.host" . | quote }}
  PGPORT: "5432"
  PGDATABASE: {{ .Values.postgresql.auth.database | quote }}
  PGUSER: {{ .Values.postgresql.auth.username | quote }}
  PORT: "8080"
  OAUTH2_ISSUER: {{ .Values.config.oauth2Issuer | quote }}
  SPRING_PROFILES_ACTIVE: {{ .Values.config.springProfiles | quote }}
  LOGGING_LEVEL_ROOT: {{ .Values.config.logLevel | quote }}
  LOGGING_LEVEL_COM_SECUREMONITOR: "DEBUG"
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/deployment.yaml">
{{- /*
Deployment template for AI Security Monitor backend
*/ -}}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "ai-security-monitor.fullname" . }}
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "ai-security-monitor.selectorLabels" . | nindent 6 }}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
      {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
      {{- end }}
      labels:
        {{- include "ai-security-monitor.selectorLabels" . | nindent 8 }}
    spec:
      {{- with .Values.imagePullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "ai-security-monitor.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          envFrom:
            - configMapRef:
                name: {{ include "ai-security-monitor.fullname" . }}-config
          env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "ai-security-monitor.fullname" . }}-secrets
                  key: database-password
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ include "ai-security-monitor.fullname" . }}-secrets
                  key: jwt-secret
            - name: GROQ_API_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "ai-security-monitor.fullname" . }}-secrets
                  key: groq-api-key
          livenessProbe:
            httpGet:
              path: {{ .Values.healthCheck.livenessPath }}
              port: http
            initialDelaySeconds: {{ .Values.healthCheck.livenessInitialDelay }}
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: {{ .Values.healthCheck.readinessPath }}
              port: http
            initialDelaySeconds: {{ .Values.healthCheck.readinessInitialDelay }}
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      terminationGracePeriodSeconds: 30
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/ingress.yaml">
{{- if .Values.ingress.enabled -}}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "ai-security-monitor.fullname" . }}
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- if .Values.ingress.className }}
  ingressClassName: {{ .Values.ingress.className }}
  {{- end }}
  {{- if .Values.ingress.tls }}
  tls:
    {{- range .Values.ingress.tls }}
    - hosts:
        {{- range .hosts }}
        - {{ . | quote }}
        {{- end }}
      secretName: {{ .secretName }}
    {{- end }}
  {{- end }}
  rules:
    {{- range .Values.ingress.hosts }}
    - host: {{ .host | quote }}
      http:
        paths:
          {{- range .paths }}
          - path: {{ .path }}
            pathType: {{ .pathType }}
            backend:
              service:
                name: {{ include "ai-security-monitor.fullname" $ }}
                port:
                  name: http
          {{- end }}
    {{- end }}
{{- end }}
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/secret.yaml">
{{- if .Values.secrets.create }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "ai-security-monitor.fullname" . }}-secrets
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
type: Opaque
data:
  database-password: {{ .Values.secrets.databasePassword | b64enc | quote }}
  jwt-secret: {{ .Values.secrets.jwtSecret | b64enc | quote }}
  groq-api-key: {{ .Values.secrets.groqApiKey | b64enc | quote }}
{{- end }}
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/service.yaml">
apiVersion: v1
kind: Service
metadata:
  name: {{ include "ai-security-monitor.fullname" . }}
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "ai-security-monitor.selectorLabels" . | nindent 4 }}
</file>

<file path="infrastructure/helm/ai-security-monitor/templates/serviceaccount.yaml">
{{- if .Values.serviceAccount.create -}}
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "ai-security-monitor.serviceAccountName" . }}
  labels:
    {{- include "ai-security-monitor.labels" . | nindent 4 }}
  {{- with .Values.serviceAccount.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
{{- end }}
</file>

<file path="infrastructure/helm/ai-security-monitor/Chart.yaml">
apiVersion: v2
name: ai-security-monitor
description: A Helm chart for AI Security Monitor - IAM demonstration with OAuth2/OIDC

type: application
version: 0.1.0
appVersion: "1.0.0"

keywords:
  - iam
  - oauth2
  - oidc
  - security
  - kotlin
  - spring-boot

home: https://github.com/dannyp19921/ai-security-monitor
sources:
  - https://github.com/dannyp19921/ai-security-monitor

maintainers:
  - name: Daniel-Aston Brandsgrd Parker
    email: daniel@example.com

dependencies:
  - name: postgresql
    version: "12.x.x"
    repository: https://charts.bitnami.com/bitnami
    condition: postgresql.enabled
</file>

<file path="infrastructure/helm/ai-security-monitor/values.yaml">
# Default values for ai-security-monitor
# This is a YAML-formatted file.

# -- Number of backend replicas
replicaCount: 2

image:
  # -- Container image repository
  repository: ai-security-monitor-backend
  # -- Image pull policy
  pullPolicy: IfNotPresent
  # -- Overrides the image tag (default is appVersion)
  tag: ""

# -- Image pull secrets for private registries
imagePullSecrets: []

# -- Override the name of the chart
nameOverride: ""

# -- Override the full name of the chart
fullnameOverride: ""

serviceAccount:
  # -- Create a service account
  create: true
  # -- Annotations for the service account
  annotations: {}
  # -- Name of the service account (generated if not set)
  name: ""

# -- Pod annotations
podAnnotations: {}

# -- Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# -- Container security context
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

service:
  # -- Service type
  type: ClusterIP
  # -- Service port
  port: 80

ingress:
  # -- Enable ingress
  enabled: true
  # -- Ingress class name
  className: nginx
  # -- Ingress annotations
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
  # -- Ingress hosts configuration
  hosts:
    - host: api.ai-security-monitor.example.com
      paths:
        - path: /
          pathType: Prefix
  # -- TLS configuration
  tls:
    - secretName: ai-security-monitor-tls
      hosts:
        - api.ai-security-monitor.example.com

# -- Resource requests and limits
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# -- Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# -- Node selector
nodeSelector: {}

# -- Tolerations
tolerations: []

# -- Affinity rules
affinity: {}

# Application configuration
config:
  # -- OAuth2 issuer URL
  oauth2Issuer: "https://api.ai-security-monitor.example.com"
  # -- Spring profiles
  springProfiles: "kubernetes"
  # -- Log level
  logLevel: "INFO"

# Secrets configuration
secrets:
  # -- Create secrets (set to false if using external secrets)
  create: true
  # -- Database password (use external secrets in production!)
  databasePassword: "change-me-in-production"
  # -- JWT signing secret (min 32 characters)
  jwtSecret: "change-me-in-production-min-32-chars!"
  # -- Groq API key
  groqApiKey: ""

# PostgreSQL configuration (using Bitnami subchart)
postgresql:
  # -- Enable PostgreSQL subchart
  enabled: true
  auth:
    # -- PostgreSQL username
    username: securemonitor
    # -- PostgreSQL database name
    database: securemonitor
    # -- Use existing secret for password
    existingSecret: ""
  primary:
    persistence:
      # -- Enable persistence
      enabled: true
      # -- Persistence size
      size: 1Gi

# Health check configuration
healthCheck:
  # -- Liveness probe path
  livenessPath: /api/health
  # -- Readiness probe path
  readinessPath: /api/health
  # -- Initial delay for liveness probe
  livenessInitialDelay: 30
  # -- Initial delay for readiness probe
  readinessInitialDelay: 10
</file>

<file path="infrastructure/kubernetes/backend-deployment.yaml">
# Kubernetes Deployment for AI Security Monitor Backend
# Defines how the application pods should be created and managed
#
# Key concepts demonstrated:
# - Rolling updates for zero-downtime deployments
# - Resource limits for stability
# - Health checks (liveness/readiness probes)
# - Security context (non-root user)
# - Environment variables from ConfigMaps and Secrets

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-security-monitor-backend
  labels:
    app: ai-security-monitor
    component: backend
    version: v1
spec:
  replicas: 2  # High availability - minimum 2 pods
  selector:
    matchLabels:
      app: ai-security-monitor
      component: backend
  
  # Rolling update strategy for zero-downtime deployments
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # Max 1 extra pod during update
      maxUnavailable: 0  # Always keep all pods available
  
  template:
    metadata:
      labels:
        app: ai-security-monitor
        component: backend
        version: v1
      annotations:
        # Force rolling update when configmap changes
        checksum/config: "{{ include (print $.Template.BasePath \"/configmap.yaml\") . | sha256sum }}"
    spec:
      # Security: Run as non-root user
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      
      containers:
        - name: backend
          image: ai-security-monitor-backend:latest
          imagePullPolicy: Always
          
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          
          # Environment variables from ConfigMap
          envFrom:
            - configMapRef:
                name: ai-security-monitor-config
          
          # Sensitive environment variables from Secret
          env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: ai-security-monitor-secrets
                  key: database-password
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: ai-security-monitor-secrets
                  key: jwt-secret
            - name: GROQ_API_KEY
              valueFrom:
                secretKeyRef:
                  name: ai-security-monitor-secrets
                  key: groq-api-key
          
          # Resource limits - important for cluster stability
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          
          # Liveness probe - restart container if unhealthy
          livenessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          
          # Readiness probe - don't route traffic until ready
          readinessProbe:
            httpGet:
              path: /api/health
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          
          # Security context for container
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false  # Spring Boot needs to write temp files
            capabilities:
              drop:
                - ALL
      
      # Graceful shutdown
      terminationGracePeriodSeconds: 30
      
      # Spread pods across nodes for high availability
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: kubernetes.io/hostname
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels:
              app: ai-security-monitor
              component: backend
</file>

<file path="infrastructure/kubernetes/backend-service.yaml">
# Kubernetes Service for AI Security Monitor Backend
# Provides stable network endpoint for the backend pods
#
# Key concepts:
# - ClusterIP for internal communication
# - Service discovery via DNS (ai-security-monitor-backend.namespace.svc.cluster.local)
# - Load balancing across pods

apiVersion: v1
kind: Service
metadata:
  name: ai-security-monitor-backend
  labels:
    app: ai-security-monitor
    component: backend
spec:
  type: ClusterIP  # Internal only - Ingress handles external traffic
  
  selector:
    app: ai-security-monitor
    component: backend
  
  ports:
    - name: http
      port: 80           # Service port
      targetPort: http   # Container port (8080)
      protocol: TCP
</file>

<file path="infrastructure/kubernetes/configmap.yaml">
# Kubernetes ConfigMap for AI Security Monitor
# Stores non-sensitive configuration as key-value pairs
#
# Key concepts:
# - Separates config from code (12-factor app principle)
# - Can be updated without rebuilding container
# - Mounted as environment variables or files

apiVersion: v1
kind: ConfigMap
metadata:
  name: ai-security-monitor-config
  labels:
    app: ai-security-monitor
data:
  # Database configuration
  PGHOST: "postgres-service"  # Kubernetes service name
  PGPORT: "5432"
  PGDATABASE: "securemonitor"
  PGUSER: "securemonitor"
  
  # Application configuration
  PORT: "8080"
  
  # OAuth2 / OIDC configuration
  OAUTH2_ISSUER: "https://ai-security-monitor.example.com"
  
  # Spring profiles
  SPRING_PROFILES_ACTIVE: "kubernetes"
  
  # Logging
  LOGGING_LEVEL_ROOT: "INFO"
  LOGGING_LEVEL_COM_SECUREMONITOR: "DEBUG"
</file>

<file path="infrastructure/kubernetes/ingress.yaml">
# Kubernetes Ingress for AI Security Monitor
# Manages external access to the services
#
# Key concepts:
# - TLS termination (HTTPS)
# - Path-based routing
# - Host-based routing
# - Integration with cert-manager for automatic TLS certificates

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ai-security-monitor-ingress
  labels:
    app: ai-security-monitor
  annotations:
    # Nginx Ingress Controller annotations
    kubernetes.io/ingress.class: nginx
    
    # TLS/SSL configuration
    cert-manager.io/cluster-issuer: letsencrypt-prod
    
    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-XSS-Protection "1; mode=block" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # CORS configuration (if needed)
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://ai-security-monitor.vercel.app"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization"
    
    # Rate limiting (basic DDoS protection)
    nginx.ingress.kubernetes.io/limit-rps: "10"
    nginx.ingress.kubernetes.io/limit-connections: "5"

spec:
  tls:
    - hosts:
        - api.ai-security-monitor.example.com
      secretName: ai-security-monitor-tls
  
  rules:
    # Backend API
    - host: api.ai-security-monitor.example.com
      http:
        paths:
          # Health check (public)
          - path: /api/health
            pathType: Prefix
            backend:
              service:
                name: ai-security-monitor-backend
                port:
                  name: http
          
          # OAuth2/OIDC endpoints
          - path: /oauth2
            pathType: Prefix
            backend:
              service:
                name: ai-security-monitor-backend
                port:
                  name: http
          
          - path: /.well-known
            pathType: Prefix
            backend:
              service:
                name: ai-security-monitor-backend
                port:
                  name: http
          
          # All other API routes
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: ai-security-monitor-backend
                port:
                  name: http
</file>

<file path="infrastructure/kubernetes/kustomization.yaml">
# Kustomization file for AI Security Monitor
# Allows applying all resources with a single command:
#   kubectl apply -k infrastructure/kubernetes/
#
# Key concepts:
# - Declarative configuration management
# - Environment-specific overlays
# - Resource generation (ConfigMaps, Secrets from files)

apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: ai-security-monitor

# Namespace for all resources
namespace: ai-security-monitor

# Resources to include (order matters for dependencies)
resources:
  - namespace.yaml
  - secrets.yaml
  - configmap.yaml
  - postgres.yaml
  - backend-deployment.yaml
  - backend-service.yaml
  - ingress.yaml

# Common labels applied to all resources
commonLabels:
  app.kubernetes.io/name: ai-security-monitor
  app.kubernetes.io/managed-by: kustomize

# Common annotations
commonAnnotations:
  app.kubernetes.io/version: "1.0.0"
</file>

<file path="infrastructure/kubernetes/namespace.yaml">
# Kubernetes Namespace for AI Security Monitor
# Isolates resources and provides RBAC boundary
#
# Key concepts:
# - Resource isolation
# - Network policies can be applied per namespace
# - Resource quotas can limit resource usage
# - RBAC can control access per namespace

apiVersion: v1
kind: Namespace
metadata:
  name: ai-security-monitor
  labels:
    app: ai-security-monitor
    environment: production
  annotations:
    description: "AI Security Monitor - IAM demonstration application"
</file>

<file path="infrastructure/kubernetes/postgres.yaml">
# PostgreSQL Deployment for AI Security Monitor
# Provides the database backend
#
# NOTE: For production, consider using:
# - Managed database service (AWS RDS, Azure Database, Google Cloud SQL)
# - PostgreSQL Operator (CrunchyData, Zalando)
# - StatefulSet with persistent storage
#
# This is a simple deployment suitable for development/testing

apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels:
    app: ai-security-monitor
    component: database
spec:
  replicas: 1  # Single instance for simplicity
  selector:
    matchLabels:
      app: ai-security-monitor
      component: database
  
  template:
    metadata:
      labels:
        app: ai-security-monitor
        component: database
    spec:
      containers:
        - name: postgres
          image: postgres:16-alpine
          
          ports:
            - containerPort: 5432
              name: postgres
          
          env:
            - name: POSTGRES_DB
              value: securemonitor
            - name: POSTGRES_USER
              value: securemonitor
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: ai-security-monitor-secrets
                  key: database-password
            # Improve performance for development
            - name: POSTGRES_HOST_AUTH_METHOD
              value: md5
          
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          
          # Persistent storage
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
          
          # Health check
          livenessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - securemonitor
            initialDelaySeconds: 30
            periodSeconds: 10
          
          readinessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - securemonitor
            initialDelaySeconds: 5
            periodSeconds: 5
      
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc

---
# Service for PostgreSQL
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  labels:
    app: ai-security-monitor
    component: database
spec:
  type: ClusterIP
  selector:
    app: ai-security-monitor
    component: database
  ports:
    - port: 5432
      targetPort: 5432
      name: postgres

---
# Persistent Volume Claim for PostgreSQL data
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  labels:
    app: ai-security-monitor
    component: database
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  # Use default storage class
  # storageClassName: standard
</file>

<file path="infrastructure/kubernetes/README.md">
# Kubernetes Deployment

This directory contains Kubernetes manifests for deploying AI Security Monitor.

## Architecture

```

                        Kubernetes Cluster                           
                                                                     
     
                      Namespace: ai-security-monitor               
                                                                   
                      
        Ingress      Service    Deployment      
        (HTTPS)           (ClusterIP)        (2 pods)       
                      
                                                                
                                                
                            ConfigMap              
                            (config)                         
                                                
                                                
                             Secret                
                           (passwords)                       
                                                
                                                                
                                                
              PostgreSQL             
                              Service                          
                                                  
                                                                
                                                  
                                PVC                            
                             (storage)                         
                                                  
     
                                                                     

```

## Files

| File | Description |
|------|-------------|
| `namespace.yaml` | Namespace for resource isolation |
| `configmap.yaml` | Non-sensitive configuration |
| `secrets.yaml` | Sensitive configuration (passwords, keys) |
| `backend-deployment.yaml` | Backend application pods |
| `backend-service.yaml` | Internal networking for backend |
| `postgres.yaml` | PostgreSQL database |
| `ingress.yaml` | External HTTPS access |
| `kustomization.yaml` | Kustomize configuration |

## Prerequisites

- Kubernetes cluster (minikube, kind, GKE, EKS, AKS, etc.)
- kubectl configured
- Docker image built and pushed to registry

## Quick Start

### 1. Build and push Docker image

```bash
# Build the image
cd backend
docker build -t your-registry/ai-security-monitor-backend:latest .

# Push to registry
docker push your-registry/ai-security-monitor-backend:latest
```

### 2. Update image reference

Edit `backend-deployment.yaml` and update the image:
```yaml
image: your-registry/ai-security-monitor-backend:latest
```

### 3. Create secrets (do NOT use the placeholder values!)

```bash
kubectl create namespace ai-security-monitor

kubectl -n ai-security-monitor create secret generic ai-security-monitor-secrets \
  --from-literal=database-password='YOUR_SECURE_PASSWORD' \
  --from-literal=jwt-secret='YOUR_256_BIT_SECRET_MIN_32_CHARS' \
  --from-literal=groq-api-key='YOUR_GROQ_API_KEY'
```

### 4. Deploy with Kustomize

```bash
# Preview what will be applied
kubectl apply -k infrastructure/kubernetes/ --dry-run=client -o yaml

# Apply all resources
kubectl apply -k infrastructure/kubernetes/

# Watch deployment progress
kubectl -n ai-security-monitor get pods -w
```

### 5. Verify deployment

```bash
# Check all resources
kubectl -n ai-security-monitor get all

# Check pod logs
kubectl -n ai-security-monitor logs -l app=ai-security-monitor,component=backend

# Port forward for local testing
kubectl -n ai-security-monitor port-forward svc/ai-security-monitor-backend 8080:80

# Test health endpoint
curl http://localhost:8080/api/health
```

## Local Development with Minikube

```bash
# Start minikube
minikube start

# Enable ingress addon
minikube addons enable ingress

# Build image directly in minikube's Docker daemon
eval $(minikube docker-env)
cd backend && docker build -t ai-security-monitor-backend:latest .

# Update deployment to use local image
# Set imagePullPolicy: Never in backend-deployment.yaml

# Deploy
kubectl apply -k infrastructure/kubernetes/

# Get minikube IP and add to /etc/hosts
echo "$(minikube ip) api.ai-security-monitor.example.com" | sudo tee -a /etc/hosts

# Access the application
curl http://api.ai-security-monitor.example.com/api/health
```

## Production Considerations

### Security
- [ ] Use proper secrets management (Vault, Sealed Secrets, External Secrets)
- [ ] Enable Network Policies to restrict pod-to-pod communication
- [ ] Use Pod Security Policies / Pod Security Standards
- [ ] Enable RBAC for namespace access
- [ ] Use service mesh for mTLS (Istio, Linkerd)

### High Availability
- [ ] Use managed PostgreSQL (RDS, Cloud SQL, Azure Database)
- [ ] Increase replica count based on load
- [ ] Configure Pod Disruption Budgets
- [ ] Use multi-zone deployment

### Monitoring
- [ ] Deploy Prometheus for metrics
- [ ] Deploy Grafana for dashboards
- [ ] Configure alerts for critical metrics
- [ ] Enable distributed tracing (Jaeger, Zipkin)

### CI/CD
- [ ] Automated image building in CI pipeline
- [ ] GitOps with ArgoCD or Flux
- [ ] Automated rollbacks on failure

## Troubleshooting

### Pods not starting
```bash
# Check pod status
kubectl -n ai-security-monitor describe pod <pod-name>

# Check events
kubectl -n ai-security-monitor get events --sort-by='.lastTimestamp'
```

### Database connection issues
```bash
# Check PostgreSQL logs
kubectl -n ai-security-monitor logs -l component=database

# Test database connectivity from backend pod
kubectl -n ai-security-monitor exec -it <backend-pod> -- nc -zv postgres-service 5432
```

### Ingress not working
```bash
# Check ingress status
kubectl -n ai-security-monitor describe ingress ai-security-monitor-ingress

# Check ingress controller logs
kubectl -n ingress-nginx logs -l app.kubernetes.io/name=ingress-nginx
```

## Relevant for Cyberforsvaret Interview

This configuration demonstrates:

1. **Container orchestration** - Kubernetes deployment patterns
2. **Security best practices** - Non-root containers, security contexts, secrets management
3. **High availability** - Multiple replicas, rolling updates, health checks
4. **Infrastructure as Code** - Declarative configuration
5. **12-factor app principles** - Config separation, stateless processes
6. **Cloud-native patterns** - Service discovery, load balancing
</file>

<file path="infrastructure/kubernetes/secrets.yaml">
# Kubernetes Secret for AI Security Monitor
# Stores sensitive configuration like passwords and API keys
#
# IMPORTANT: 
# - In production, use a proper secrets management solution:
#   - HashiCorp Vault
#   - AWS Secrets Manager
#   - Azure Key Vault
#   - Sealed Secrets
# - Never commit actual secrets to Git!
# - This file contains placeholder values for demonstration
#
# Key concepts:
# - Base64 encoded values (not encryption!)
# - Mounted as environment variables or files
# - RBAC controls who can read secrets

apiVersion: v1
kind: Secret
metadata:
  name: ai-security-monitor-secrets
  labels:
    app: ai-security-monitor
type: Opaque
data:
  # Base64 encoded values
  # To encode: echo -n 'your-value' | base64
  # To decode: echo 'encoded-value' | base64 -d
  
  # Database password (placeholder: "change-me-in-production")
  database-password: Y2hhbmdlLW1lLWluLXByb2R1Y3Rpb24=
  
  # JWT signing secret (placeholder: "your-256-bit-secret-key-here-min-32-chars")
  jwt-secret: eW91ci0yNTYtYml0LXNlY3JldC1rZXktaGVyZS1taW4tMzItY2hhcnM=
  
  # Groq API key (placeholder: "your-groq-api-key")
  groq-api-key: eW91ci1ncm9xLWFwaS1rZXk=

---
# Example: How to create secrets from command line (more secure):
#
# kubectl create secret generic ai-security-monitor-secrets \
#   --from-literal=database-password='actual-password' \
#   --from-literal=jwt-secret='actual-jwt-secret-min-32-chars' \
#   --from-literal=groq-api-key='actual-groq-key'
</file>

<file path="infrastructure/README.md">
# Infrastructure

This directory contains infrastructure configurations for deploying AI Security Monitor.

## Structure

```
infrastructure/
 kubernetes/          # Raw Kubernetes manifests
    namespace.yaml
    configmap.yaml
    secrets.yaml
    backend-deployment.yaml
    backend-service.yaml
    postgres.yaml
    ingress.yaml
    kustomization.yaml
    README.md

 helm/               # Helm chart for templated deployment
     ai-security-monitor/
         Chart.yaml
         values.yaml
         templates/
             _helpers.tpl
             deployment.yaml
             service.yaml
             configmap.yaml
             secret.yaml
             ingress.yaml
             serviceaccount.yaml
```

## Deployment Options

### Option 1: Raw Kubernetes (simple, for learning)

```bash
# Apply all resources
kubectl apply -k kubernetes/
```

### Option 2: Helm (recommended for production)

```bash
# Install with default values
helm install ai-security-monitor helm/ai-security-monitor/

# Install with custom values
helm install ai-security-monitor helm/ai-security-monitor/ \
  --set config.oauth2Issuer=https://your-domain.com \
  --set secrets.databasePassword=your-secure-password

# Upgrade existing release
helm upgrade ai-security-monitor helm/ai-security-monitor/
```

## Why Two Options?

| Aspect | Raw Kubernetes | Helm |
|--------|---------------|------|
| Learning | Easier to understand | More complex |
| Reusability | Copy/paste | Parameterized |
| Environment configs | Manual editing | values.yaml per env |
| Upgrades | kubectl apply | helm upgrade |
| Rollback | Manual | helm rollback |
| Dependencies | Manual | Chart dependencies |

## Relevance for Job Applications

### DF (IAM Advisor)
- Infrastructure as Code principles
- Security configurations (secrets management, RBAC)
- Enterprise deployment patterns

### Cyberforsvaret (Open Source Developer)
- Kubernetes proficiency (directly mentioned as "nskelig")
- Container orchestration
- Cloud-native application design
- DevOps practices
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.gradle/
build/

# Environment
.env
.env.local

# IDE
.idea/
.vscode/
*.swp

# Build outputs
dist/
target/
*.jar

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/
</file>

<file path="docker-compose.yml">
## (root-folder)/docker-compose.yml
version: '3.8'

services:
  database:
    image: postgres:16-alpine
    container_name: securemonitor-db
    environment:
      POSTGRES_DB: securemonitor
      POSTGRES_USER: securemonitor
      POSTGRES_PASSWORD: localdev123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: ./backend
    container_name: securemonitor-backend
    depends_on:
      - database
    environment:
      PGHOST: database
      PGPORT: 5432
      PGDATABASE: securemonitor
      PGUSER: securemonitor
      PGPASSWORD: localdev123
      GROQ_API_KEY: ${GROQ_API_KEY}
    ports:
      - "8080:8080"

volumes:
  postgres_data:
</file>

<file path=".github/workflows/ci.yml">
# .github/workflows/ci.yml

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  backend:
    name: Backend Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: ${{ runner.os }}-gradle-

      - name: Build and test backend
        working-directory: ./backend
        run: ./gradlew build -x test

  frontend:
    name: Frontend Build
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend
        working-directory: ./frontend
        run: npm run build
</file>

<file path="backend/src/main/kotlin/com/securemonitor/controller/AuthController.kt">
// backend/src/main/kotlin/com/securemonitor/controller/AuthController.kt
package com.securemonitor.controller

import com.securemonitor.dto.AuthResponse
import com.securemonitor.dto.LoginRequest
import com.securemonitor.dto.RegisterRequest
import com.securemonitor.service.AuthService
import com.securemonitor.security.JwtService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/auth")
class AuthController(
    private val authService: AuthService,
    private val jwtService: JwtService
) {

    @PostMapping("/register")
    fun register(
        @RequestBody request: RegisterRequest,
        httpRequest: HttpServletRequest
    ): ResponseEntity<AuthResponse> {
        val ipAddress = getClientIp(httpRequest)
        val user = authService.register(request.username, request.email, request.password, ipAddress)
        val roles = user.roles.map { it.name }
        val token = jwtService.generateToken(user.username, roles)

        return ResponseEntity.ok(AuthResponse(
            token = token,
            username = user.username,
            roles = roles
        ))
    }

    @PostMapping("/login")
    fun login(
        @RequestBody request: LoginRequest,
        httpRequest: HttpServletRequest
    ): ResponseEntity<AuthResponse> {
        val ipAddress = getClientIp(httpRequest)
        val token = authService.login(request.username, request.password, ipAddress)
        val username = jwtService.getUsername(token)
        val roles = jwtService.getRoles(token)

        return ResponseEntity.ok(AuthResponse(
            token = token,
            username = username,
            roles = roles
        ))
    }

    private fun getClientIp(request: HttpServletRequest): String {
        val xForwardedFor = request.getHeader("X-Forwarded-For")
        return if (xForwardedFor != null) {
            xForwardedFor.split(",")[0].trim()
        } else {
            request.remoteAddr
        }
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/dto/AuthDtos.kt">
// backend/src/main/kotlin/com/securemonitor/dto/AuthDtos.kt 
package com.securemonitor.dto

data class RegisterRequest(
    val username: String,
    val email: String,
    val password: String
)

data class LoginRequest(
    val username: String,
    val password: String
)

data class AuthResponse(
    val token: String,
    val username: String,
    val roles: List<String>
)

data class UserResponse(
    val id: Long,
    val username: String,
    val email: String,
    val roles: List<String>,
    val enabled: Boolean,
    val createdAt: String,
    val lastLogin: String?
)

data class ChatRequest(
    val message: String
)

data class ChatResponse(
    val response: String,
    val timestamp: String = java.time.Instant.now().toString()
)
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/service/AuthorizationService.kt">
package com.securemonitor.oauth2.service

import com.securemonitor.oauth2.dto.AuthorizationRequest
import com.securemonitor.oauth2.exception.OAuth2Exception
import com.securemonitor.oauth2.model.AuthorizationCode
import com.securemonitor.oauth2.model.OAuth2Client
import com.securemonitor.oauth2.repository.AuthorizationCodeRepository
import com.securemonitor.oauth2.repository.OAuth2ClientRepository
import com.securemonitor.service.AuditService
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import java.security.SecureRandom
import java.time.Instant
import java.util.Base64

/**
 * Service handling OAuth 2.0 authorization requests.
 * 
 * This service implements the authorization endpoint logic as defined in
 * RFC 6749 Section 4.1. It handles:
 * - Request validation
 * - Client authentication
 * - PKCE validation
 * - Authorization code generation
 * - Redirect URI construction
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1">RFC 6749 Section 4.1</a>
 */
@Service
class AuthorizationService(
    private val clientRepository: OAuth2ClientRepository,
    private val codeRepository: AuthorizationCodeRepository,
    private val pkceService: PkceService,
    private val auditService: AuditService
) {
    private val log = LoggerFactory.getLogger(AuthorizationService::class.java)
    private val secureRandom = SecureRandom()

    companion object {
        /** Supported response types */
        val SUPPORTED_RESPONSE_TYPES = setOf("code")
        
        /** Length of generated authorization codes */
        const val CODE_LENGTH = 32
        
        /** Authorization code lifetime in seconds */
        const val CODE_LIFETIME_SECONDS = 600L // 10 minutes
    }

    /**
     * Validates an authorization request and returns the validated client.
     * 
     * This method performs all validation required before showing the consent
     * screen to the user. Validation includes:
     * - response_type must be "code"
     * - client_id must exist and be enabled
     * - redirect_uri must be registered for the client
     * - scope must be allowed for the client
     * - PKCE must be present if required by the client
     * 
     * @param request The authorization request to validate
     * @return The validated OAuth2Client
     * @throws OAuth2Exception if validation fails
     */
    fun validateAuthorizationRequest(request: AuthorizationRequest): OAuth2Client {
        log.debug("Validating authorization request for client: {}", request.clientId)
        
        // Validate response_type
        if (request.responseType !in SUPPORTED_RESPONSE_TYPES) {
            log.warn("Unsupported response_type: {}", request.responseType)
            throw OAuth2Exception(
                error = "unsupported_response_type",
                errorDescription = "Response type '${request.responseType}' is not supported. " +
                    "Supported types: $SUPPORTED_RESPONSE_TYPES"
            )
        }
        
        // Find and validate client
        val client = clientRepository.findByClientId(request.clientId).orElseThrow {
            log.warn("Unknown client_id: {}", request.clientId)
            OAuth2Exception.invalidClient("Client '${request.clientId}' not found")
        }
        
        // Check if client is enabled
        if (!client.enabled) {
            log.warn("Disabled client attempted authorization: {}", request.clientId)
            throw OAuth2Exception.invalidClient("Client '${request.clientId}' is disabled")
        }
        
        // Validate redirect_uri
        if (!client.isRedirectUriAllowed(request.redirectUri)) {
            log.warn(
                "Invalid redirect_uri for client {}: {}. Allowed: {}",
                request.clientId, request.redirectUri, client.redirectUris
            )
            throw OAuth2Exception.invalidRequest(
                "Invalid redirect_uri. The redirect URI must exactly match a registered URI."
            )
        }
        
        // Validate scope
        if (!client.areAllScopesAllowed(request.scope)) {
            log.warn(
                "Invalid scope for client {}: {}. Allowed: {}",
                request.clientId, request.scope, client.allowedScopes
            )
            throw OAuth2Exception.invalidScope(
                "One or more requested scopes are not allowed for this client. " +
                "Allowed scopes: ${client.allowedScopes}"
            )
        }
        
        // Validate PKCE if required
        if (client.requirePkce && request.codeChallenge.isNullOrBlank()) {
            log.warn("PKCE required but not provided for client: {}", request.clientId)
            throw OAuth2Exception.invalidRequest(
                "PKCE is required for this client. " +
                "Please include code_challenge and code_challenge_method parameters."
            )
        }
        
        // Validate code_challenge_method if code_challenge is present
        if (!request.codeChallenge.isNullOrBlank()) {
            val method = request.codeChallengeMethod ?: "plain"
            if (method !in PkceService.SUPPORTED_METHODS) {
                throw OAuth2Exception.invalidRequest(
                    "Unsupported code_challenge_method: $method. " +
                    "Supported methods: ${PkceService.SUPPORTED_METHODS}"
                )
            }
        }
        
        log.debug("Authorization request validated successfully for client: {}", request.clientId)
        return client
    }

    /**
     * Creates an authorization code after user consent.
     * 
     * The authorization code is a cryptographically secure random string that
     * is bound to the client, user, redirect URI, and PKCE parameters. It is
     * single-use and short-lived.
     * 
     * @param client The validated OAuth2 client
     * @param request The original authorization request
     * @param userId The ID of the user who consented
     * @param username The username of the user who consented
     * @return The created AuthorizationCode
     */
    @Transactional
    fun createAuthorizationCode(
        client: OAuth2Client,
        request: AuthorizationRequest,
        userId: Long,
        username: String
    ): AuthorizationCode {
        val codeValue = generateSecureCode()
        val now = Instant.now()
        
        val authorizationCode = AuthorizationCode(
            code = codeValue,
            clientId = client.clientId,
            userId = userId,
            username = username,
            redirectUri = request.redirectUri,
            scope = request.scope,
            codeChallenge = request.codeChallenge,
            codeChallengeMethod = request.codeChallengeMethod,
            nonce = request.nonce,
            issuedAt = now,
            expiresAt = now.plusSeconds(CODE_LIFETIME_SECONDS)
        )
        
        val savedCode = codeRepository.save(authorizationCode)
        
        auditService.log(
            action = "OAUTH2_CODE_ISSUED",
            username = username,
            resourceType = "OAUTH2_CLIENT",
            resourceId = client.clientId,
            details = "Authorization code issued. Scope: ${request.scope ?: "default"}, " +
                "PKCE: ${request.codeChallenge != null}",
            success = true
        )
        
        log.info(
            "Authorization code issued for user {} to client {}",
            username, client.clientId
        )
        
        return savedCode
    }

    /**
     * Builds the redirect URI with the authorization code.
     * 
     * @param baseRedirectUri The base redirect URI from the request
     * @param code The authorization code
     * @param state The state parameter (if provided)
     * @return The complete redirect URI
     */
    fun buildAuthorizationRedirect(
        baseRedirectUri: String,
        code: String,
        state: String?
    ): String {
        val params = mutableListOf<String>()
        params.add("code=${urlEncode(code)}")
        state?.let { params.add("state=${urlEncode(it)}") }
        
        return appendQueryParams(baseRedirectUri, params)
    }

    /**
     * Builds an error redirect URI.
     * 
     * @param baseRedirectUri The base redirect URI
     * @param error The error code
     * @param errorDescription Human-readable error description
     * @param state The state parameter (if provided)
     * @return The error redirect URI
     */
    fun buildErrorRedirect(
        baseRedirectUri: String,
        error: String,
        errorDescription: String?,
        state: String?
    ): String {
        val params = mutableListOf<String>()
        params.add("error=${urlEncode(error)}")
        errorDescription?.let { params.add("error_description=${urlEncode(it)}") }
        state?.let { params.add("state=${urlEncode(it)}") }
        
        return appendQueryParams(baseRedirectUri, params)
    }

    /**
     * Generates a cryptographically secure authorization code.
     */
    private fun generateSecureCode(): String {
        val bytes = ByteArray(CODE_LENGTH)
        secureRandom.nextBytes(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes)
    }

    /**
     * URL-encodes a string.
     */
    private fun urlEncode(value: String): String =
        URLEncoder.encode(value, StandardCharsets.UTF_8)

    /**
     * Appends query parameters to a URI.
     */
    private fun appendQueryParams(uri: String, params: List<String>): String {
        if (params.isEmpty()) return uri
        
        val separator = if (uri.contains("?")) "&" else "?"
        return uri + separator + params.joinToString("&")
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/oauth2/service/TokenService.kt">
package com.securemonitor.oauth2.service

import com.securemonitor.oauth2.dto.TokenRequest
import com.securemonitor.oauth2.dto.TokenResponse
import com.securemonitor.oauth2.exception.OAuth2Exception
import com.securemonitor.oauth2.model.AuthorizationCode
import com.securemonitor.oauth2.repository.AuthorizationCodeRepository
import com.securemonitor.oauth2.repository.OAuth2ClientRepository
import com.securemonitor.service.AuditService
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.security.Keys
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.security.SecureRandom
import java.time.Instant
import java.util.*
import javax.crypto.SecretKey

/**
 * Service handling OAuth 2.0 token requests.
 * 
 * This service implements the token endpoint logic as defined in
 * RFC 6749 Section 4.1.3 and Section 6. It handles:
 * - Authorization code exchange
 * - Refresh token exchange
 * - PKCE verification
 * - JWT access token generation
 * - ID token generation (OIDC)
 * 
 * @see <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3">RFC 6749 Section 4.1.3</a>
 */
@Service
class TokenService(
    private val clientRepository: OAuth2ClientRepository,
    private val codeRepository: AuthorizationCodeRepository,
    private val pkceService: PkceService,
    private val auditService: AuditService,
    @Value("\${oauth2.issuer:http://localhost:8080}")
    private val issuer: String,
    @Value("\${oauth2.access-token-lifetime:3600}")
    private val accessTokenLifetimeSeconds: Long,
    @Value("\${oauth2.refresh-token-lifetime:86400}")
    private val refreshTokenLifetimeSeconds: Long,
    @Value("\${jwt.secret:myDefaultSecretKeyThatIsAtLeast256BitsLong123456}")
    private val jwtSecret: String = "myDefaultSecretKeyThatIsAtLeast256BitsLong123456"
) {
    private val log = LoggerFactory.getLogger(TokenService::class.java)
    private val secureRandom = SecureRandom()
    
    private val secretKey: SecretKey by lazy {
        Keys.hmacShaKeyFor(jwtSecret.toByteArray())
    }

    companion object {
        /** Supported grant types */
        val SUPPORTED_GRANT_TYPES = setOf(
            "authorization_code",
            "refresh_token"
        )
    }

    /**
     * Exchanges an authorization code for access and refresh tokens.
     * 
     * This method:
     * 1. Validates the authorization code
     * 2. Verifies the client and redirect_uri match
     * 3. Verifies PKCE if present
     * 4. Marks the code as used
     * 5. Generates and returns tokens
     * 
     * @param request The token request
     * @return TokenResponse containing access_token, refresh_token, etc.
     * @throws OAuth2Exception if validation fails
     */
    @Transactional
    fun exchangeAuthorizationCode(request: TokenRequest): TokenResponse {
        log.debug("Processing authorization code exchange for client: {}", request.clientId)
        
        // Validate grant type
        validateGrantType(request.grantType)
        
        // Find and validate authorization code
        val authCode = codeRepository.findValidCode(request.code!!, Instant.now())
            .orElseThrow {
                log.warn("Invalid or expired authorization code")
                OAuth2Exception.invalidGrant("Authorization code is invalid, expired, or has already been used")
            }
        
        // Verify client_id matches
        if (authCode.clientId != request.clientId) {
            log.warn(
                "Client ID mismatch. Code issued to: {}, Request from: {}",
                authCode.clientId, request.clientId
            )
            throw OAuth2Exception.invalidGrant("Authorization code was not issued to this client")
        }
        
        // Verify redirect_uri matches
        if (authCode.redirectUri != request.redirectUri) {
            log.warn(
                "Redirect URI mismatch. Code: {}, Request: {}",
                authCode.redirectUri, request.redirectUri
            )
            throw OAuth2Exception.invalidGrant("redirect_uri does not match the one used in authorization request")
        }
        
        // Get client for additional validation
        val client = clientRepository.findByClientId(request.clientId!!)
            .orElseThrow {
                OAuth2Exception.invalidClient("Client not found")
            }
        
        // Verify PKCE if code challenge was present
        val codeChallenge = authCode.codeChallenge
        if (codeChallenge != null) {
            if (request.codeVerifier.isNullOrBlank()) {
                log.warn("PKCE code_verifier missing for code that requires it")
                throw OAuth2Exception.invalidGrant(
                    "code_verifier is required because code_challenge was used in authorization"
                )
            }
            
            val pkceValid = pkceService.verifyCodeChallenge(
                codeVerifier = request.codeVerifier,
                codeChallenge = codeChallenge,  // <-- N fungerer smart cast
                method = authCode.codeChallengeMethod ?: "S256"
            )
            
            if (!pkceValid) {
                log.warn("PKCE verification failed for client: {}", request.clientId)
                auditService.log(
                    action = "OAUTH2_PKCE_FAILED",
                    username = authCode.username,
                    resourceType = "OAUTH2_CLIENT",
                    resourceId = client.clientId,
                    details = "PKCE code_verifier validation failed",
                    success = false
                )
                throw OAuth2Exception.invalidGrant("PKCE verification failed. code_verifier does not match code_challenge")
            }
        }
        
        // Mark code as used (single-use)
        authCode.markAsUsed()
        codeRepository.save(authCode)
        
        // Generate tokens
        val accessToken = generateAccessToken(
            subject = authCode.userId.toString(),
            username = authCode.username,
            clientId = client.clientId,
            scope = authCode.scope,
            lifetime = client.accessTokenLifetimeSeconds
        )
        
        val refreshToken = generateRefreshToken()
        
        // Generate ID token if openid scope was requested
        val idToken = if (authCode.getScopeSet().contains("openid")) {
            generateIdToken(
                subject = authCode.userId.toString(),
                username = authCode.username,
                clientId = client.clientId,
                nonce = authCode.nonce
            )
        } else null
        
        auditService.log(
            action = "OAUTH2_TOKEN_ISSUED",
            username = authCode.username,
            resourceType = "OAUTH2_CLIENT",
            resourceId = client.clientId,
            details = "Tokens issued. Scope: ${authCode.scope ?: "default"}, ID Token: ${idToken != null}",
            success = true
        )
        
        log.info("Tokens issued for user {} to client {}", authCode.username, client.clientId)
        
        return TokenResponse(
            accessToken = accessToken,
            tokenType = "Bearer",
            expiresIn = client.accessTokenLifetimeSeconds,
            refreshToken = refreshToken,
            scope = authCode.scope,
            idToken = idToken
        )
    }

    /**
     * Validates that the grant type is supported.
     * 
     * @param grantType The grant type to validate
     * @throws OAuth2Exception if grant type is not supported
     */
    fun validateGrantType(grantType: String) {
        if (grantType !in SUPPORTED_GRANT_TYPES) {
            throw OAuth2Exception.unsupportedGrantType(grantType)
        }
    }

    /**
     * Generates a JWT access token.
     */
    private fun generateAccessToken(
        subject: String,
        username: String,
        clientId: String,
        scope: String?,
        lifetime: Long
    ): String {
        val now = Instant.now()
        val expiry = now.plusSeconds(lifetime)
        
        return Jwts.builder()
            .subject(subject)
            .issuer(issuer)
            .audience().add(clientId).and()
            .issuedAt(Date.from(now))
            .expiration(Date.from(expiry))
            .claim("username", username)
            .claim("scope", scope ?: "")
            .claim("token_type", "access_token")
            .signWith(secretKey)
            .compact()
    }

    /**
     * Generates an OIDC ID token.
     */
    private fun generateIdToken(
        subject: String,
        username: String,
        clientId: String,
        nonce: String?
    ): String {
        val now = Instant.now()
        val expiry = now.plusSeconds(3600) // ID tokens typically have shorter lifetime
        
        val builder = Jwts.builder()
            .subject(subject)
            .issuer(issuer)
            .audience().add(clientId).and()
            .issuedAt(Date.from(now))
            .expiration(Date.from(expiry))
            .claim("auth_time", now.epochSecond)
            .claim("preferred_username", username)
        
        // Include nonce if provided (for replay protection)
        nonce?.let { builder.claim("nonce", it) }
        
        return builder.signWith(secretKey).compact()
    }

    /**
     * Generates a secure refresh token.
     */
    private fun generateRefreshToken(): String {
        val bytes = ByteArray(32)
        secureRandom.nextBytes(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes)
    }
}
</file>

<file path="frontend/src/types/index.ts">
// frontend/src/types/index.ts
export interface User {
  id: number;
  username: string;
  email: string;
  roles: string[];
  enabled: boolean;
  createdAt: string;
  lastLogin: string | null;
}

export interface AuthResponse {
  token: string;
  username: string;
  roles: string[];
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
}

export interface AuditLog {
  id: number;
  timestamp: string;
  action: string;
  username: string;
  resourceType: string | null;
  resourceId: string | null;
  ipAddress: string | null;
  details: string | null;
  success: boolean;
}

export interface UserResponse {
  id: number;
  username: string;
  email: string;
  roles: string[];
  enabled: boolean;
  createdAt: string;
  lastLogin: string | null;
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/controller/AdminController.kt">
// backend/src/main/kotlin/com/securemonitor/controller/AdminController.kt
package com.securemonitor.controller

import com.securemonitor.dto.UserResponse
import com.securemonitor.model.User
import com.securemonitor.repository.UserRepository
import com.securemonitor.repository.RoleRepository
import com.securemonitor.service.AuditService
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
class AdminController(
    private val userRepository: UserRepository,
    private val roleRepository: RoleRepository,
    private val auditService: AuditService
) {

    @GetMapping("/users")
    fun getAllUsers(): ResponseEntity<List<UserResponse>> {
        val users = userRepository.findAll().map { it.toResponse() }
        
        auditService.log(
            action = "ADMIN_VIEW_USERS",
            username = SecurityContextHolder.getContext().authentication?.name ?: "unknown",
            resourceType = "USER",
            details = "Listed ${users.size} users"
        )
        
        return ResponseEntity.ok(users)
    }

    @PostMapping("/users/{userId}/roles/{roleName}")
    fun addRoleToUser(
        @PathVariable userId: Long,
        @PathVariable roleName: String
    ): ResponseEntity<UserResponse> {
        val user = userRepository.findById(userId)
            .orElseThrow { IllegalArgumentException("User not found") }
        
        val role = roleRepository.findByName(roleName)
            .orElseThrow { IllegalArgumentException("Role not found") }
        
        user.roles.add(role)
        val savedUser = userRepository.save(user)
        
        auditService.log(
            action = "ADMIN_ADD_ROLE",
            username = SecurityContextHolder.getContext().authentication?.name ?: "unknown",
            resourceType = "USER",
            resourceId = userId.toString(),
            details = "Added role $roleName to user ${user.username}"
        )
        
        return ResponseEntity.ok(savedUser.toResponse())
    }

    @DeleteMapping("/users/{userId}/roles/{roleName}")
    fun removeRoleFromUser(
        @PathVariable userId: Long,
        @PathVariable roleName: String
    ): ResponseEntity<UserResponse> {
        val user = userRepository.findById(userId)
            .orElseThrow { IllegalArgumentException("User not found") }
        
        val role = roleRepository.findByName(roleName)
            .orElseThrow { IllegalArgumentException("Role not found") }
        
        user.roles.remove(role)
        val savedUser = userRepository.save(user)
        
        auditService.log(
            action = "ADMIN_REMOVE_ROLE",
            username = SecurityContextHolder.getContext().authentication?.name ?: "unknown",
            resourceType = "USER",
            resourceId = userId.toString(),
            details = "Removed role $roleName from user ${user.username}"
        )
        
        return ResponseEntity.ok(savedUser.toResponse())
    }

    private fun User.toResponse() = UserResponse(
        id = this.id,
        username = this.username,
        email = this.email,
        roles = this.roles.map { it.name },
        enabled = this.enabled,
        createdAt = this.createdAt.toString(),
        lastLogin = this.lastLogin?.toString()
    )
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/model/User.kt">
// backend/src/main/kotlin/com/securemonitor/model/User.kt
package com.securemonitor.model

import jakarta.persistence.*
import java.time.Instant

@Entity
@Table(name = "users")
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(unique = true, nullable = false)
    val username: String,

    @Column(unique = true, nullable = false)
    val email: String,

    @Column(nullable = false)
    val passwordHash: String,

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = [JoinColumn(name = "user_id")],
        inverseJoinColumns = [JoinColumn(name = "role_id")]
    )
    var roles: MutableSet<Role> = mutableSetOf(),

    @Column(nullable = false)
    val enabled: Boolean = true,

    @Column(nullable = false)
    val createdAt: Instant = Instant.now(),

    @Column
    val lastLogin: Instant? = null
)
</file>

<file path="backend/src/main/kotlin/com/securemonitor/service/AuthService.kt">
// backend/src/main/kotlin/com/securemonitor/service/AuthService.kt
package com.securemonitor.service

import com.securemonitor.model.Role
import com.securemonitor.model.User
import com.securemonitor.repository.RoleRepository
import com.securemonitor.repository.UserRepository
import com.securemonitor.security.JwtService
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import java.time.Instant

@Service
class AuthService(
    private val userRepository: UserRepository,
    private val roleRepository: RoleRepository,
    private val passwordEncoder: PasswordEncoder,
    private val jwtService: JwtService,
    private val auditService: AuditService
) {

    fun register(username: String, email: String, password: String, ipAddress: String? = null): User {
        if (userRepository.existsByUsername(username)) {
            auditService.log(
                action = "REGISTER_FAILED",
                username = username,
                details = "Username already exists",
                ipAddress = ipAddress,
                success = false
            )
            throw IllegalArgumentException("Username already exists")
        }
        if (userRepository.existsByEmail(email)) {
            auditService.log(
                action = "REGISTER_FAILED",
                username = username,
                details = "Email already exists",
                ipAddress = ipAddress,
                success = false
            )
            throw IllegalArgumentException("Email already exists")
        }

        val userRole = roleRepository.findByName("USER")
            .orElseGet { roleRepository.save(Role(name = "USER", description = "Standard user")) }

        val user = User(
            username = username,
            email = email,
            passwordHash = passwordEncoder.encode(password),
            roles = mutableSetOf(userRole)
        )

        val savedUser = userRepository.save(user)

        auditService.log(
            action = "USER_REGISTERED",
            username = username,
            resourceType = "USER",
            resourceId = savedUser.id.toString(),
            ipAddress = ipAddress,
            details = "New user registered with email: $email"
        )

        return savedUser
    }

    fun login(username: String, password: String, ipAddress: String? = null): String {
        val user = userRepository.findByUsername(username).orElse(null)

        if (user == null) {
            auditService.log(
                action = "LOGIN_FAILED",
                username = username,
                details = "User not found",
                ipAddress = ipAddress,
                success = false
            )
            throw IllegalArgumentException("Invalid credentials")
        }

        if (!passwordEncoder.matches(password, user.passwordHash)) {
            auditService.log(
                action = "LOGIN_FAILED",
                username = username,
                details = "Invalid password",
                ipAddress = ipAddress,
                success = false
            )
            throw IllegalArgumentException("Invalid credentials")
        }

        if (!user.enabled) {
            auditService.log(
                action = "LOGIN_FAILED",
                username = username,
                details = "Account disabled",
                ipAddress = ipAddress,
                success = false
            )
            throw IllegalArgumentException("Account is disabled")
        }

        userRepository.save(user.copy(lastLogin = Instant.now()))

        auditService.log(
            action = "USER_LOGIN",
            username = username,
            resourceType = "USER",
            resourceId = user.id.toString(),
            ipAddress = ipAddress
        )

        val roles = user.roles.map { it.name }
        return jwtService.generateToken(user.username, roles)
    }
}
</file>

<file path="backend/src/main/kotlin/com/securemonitor/BackendApplication.kt">
// backend/src/main/kotlin/com/securemonitor/BackendApplication.kt
package com.securemonitor

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class BackendApplication

fun main(args: Array<String>) {
    runApplication<BackendApplication>(*args)
}
</file>

<file path="backend/build.gradle.kts">
// backend/build.gradle.kts
plugins {
	kotlin("jvm") version "1.9.25"
	kotlin("plugin.spring") version "1.9.25"
	id("org.springframework.boot") version "3.5.0"
	id("io.spring.dependency-management") version "1.1.7"
	kotlin("plugin.jpa") version "1.9.25"
}

group = "com.securemonitor"
version = "0.0.1-SNAPSHOT"
description = "Demo project for Spring Boot"

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation("org.springframework.boot:spring-boot-starter-data-jpa")
	implementation("org.springframework.boot:spring-boot-starter-security")
	implementation("org.springframework.boot:spring-boot-starter-validation")
	implementation("org.springframework.boot:spring-boot-starter-web")
	implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
	implementation("org.jetbrains.kotlin:kotlin-reflect")

	runtimeOnly("org.postgresql:postgresql")
	testImplementation("org.springframework.boot:spring-boot-starter-test")
	testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
	testImplementation("org.springframework.security:spring-security-test")
	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
	// Mockito Kotlin extensions for testing
	testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")

	// JWT 
	implementation("io.jsonwebtoken:jjwt-api:0.12.5")
	runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.5")
	runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.5")

	implementation("org.springframework.boot:spring-boot-starter-webflux")

	implementation("me.paulschwarz:spring-dotenv:4.0.0")

	// OAuth2 Client (for OIDC Consumer functionality)
   	implementation("org.springframework.boot:spring-boot-starter-oauth2-client")
}

kotlin {
	compilerOptions {
		freeCompilerArgs.addAll("-Xjsr305=strict")
	}
}

allOpen {
	annotation("jakarta.persistence.Entity")
	annotation("jakarta.persistence.MappedSuperclass")
	annotation("jakarta.persistence.Embeddable")
}

tasks.withType<Test> {
	useJUnitPlatform()
}
</file>

<file path="frontend/src/pages/DashboardPage.tsx">
// frontend/src/pages/DashboardPage.tsx
import { useState, useEffect } from 'react';
import { useAuth } from '../hooks/useAuth';
import { auditService } from '../services/api';
import { Button } from '../components/ui/Button';
import { AiChat } from '../components/chat/AiChat';
import { AdminPanel } from '../components/admin/AdminPanel';
import type { AuditLog } from '../types';

interface DashboardPageProps {
  onLogout: () => void;
}

export function DashboardPage({ onLogout }: DashboardPageProps) {
  const { username, roles, logout, hasRole } = useAuth();
  const [auditLogs, setAuditLogs] = useState<AuditLog[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    const fetchLogs = async () => {
      try {
        const logs = await auditService.getRecentLogs();
        setAuditLogs(logs);
      } catch (err) {
        setError('Failed to load audit logs');
      } finally {
        setIsLoading(false);
      }
    };

    fetchLogs();
  }, []);

  const handleLogout = () => {
    logout();
    onLogout();
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold text-gray-900">AI Security Monitor</h1>
          <div className="flex items-center gap-4">
            <span className="text-sm text-gray-600 hidden sm:block">
              {username}
              {hasRole('ADMIN') && (
                <span className="ml-2 px-2 py-1 bg-purple-100 text-purple-800 rounded-full text-xs font-medium">
                  ADMIN
                </span>
              )}
            </span>
            <Button variant="secondary" onClick={handleLogout} className="!w-auto !py-2">
              Logout
            </Button>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 py-6 space-y-6">
        {/* Top Row: User Info + AI Chat */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* User Info Card */}
          <div className="bg-white rounded-xl shadow-sm p-6">
            <h2 className="text-lg font-semibold text-gray-900 mb-4">User Profile</h2>
            <div className="space-y-3">
              <div>
                <span className="text-sm text-gray-500">Username</span>
                <p className="font-medium text-gray-900">{username}</p>
              </div>
              <div>
                <span className="text-sm text-gray-500">Roles</span>
                <div className="flex gap-2 mt-1">
                  {roles.map((role) => (
                    <span
                      key={role}
                      className={`px-3 py-1 rounded-full text-sm font-medium ${
                        role === 'ADMIN' 
                          ? 'bg-purple-100 text-purple-800' 
                          : 'bg-blue-100 text-blue-800'
                      }`}
                    >
                      {role}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>

          {/* AI Chat */}
          <AiChat />
        </div>

        {/* Admin Panel - Only visible for admins */}
        {hasRole('ADMIN') && <AdminPanel />}

        {/* Audit Logs Card */}
        <div className="bg-white rounded-xl shadow-sm p-6">
          <h2 className="text-lg font-semibold text-gray-900 mb-4">Security Audit Log</h2>
          
          {isLoading ? (
            <div className="flex justify-center py-8">
              <svg className="animate-spin h-8 w-8 text-blue-600" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
              </svg>
            </div>
          ) : error ? (
            <div className="p-4 bg-red-50 rounded-lg">
              <p className="text-red-600">{error}</p>
            </div>
          ) : auditLogs.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              No audit logs found
            </div>
          ) : (
            <div className="overflow-x-auto">
              {/* Mobile View */}
              <div className="sm:hidden space-y-4">
                {auditLogs.map((log) => (
                  <div key={log.id} className="border rounded-lg p-4 space-y-2">
                    <div className="flex justify-between items-start">
                      <span className={`px-2 py-1 rounded text-xs font-medium ${
                        log.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                      }`}>
                        {log.action}
                      </span>
                      <span className="text-xs text-gray-500">{formatDate(log.timestamp)}</span>
                    </div>
                    <p className="text-sm text-gray-900">{log.username}</p>
                    {log.ipAddress && (
                      <p className="text-xs text-gray-500">IP: {log.ipAddress}</p>
                    )}
                  </div>
                ))}
              </div>

              {/* Desktop View */}
              <table className="hidden sm:table w-full">
                <thead>
                  <tr className="border-b">
                    <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Time</th>
                    <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Action</th>
                    <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">User</th>
                    <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">IP Address</th>
                    <th className="text-left py-3 px-4 text-sm font-medium text-gray-500">Status</th>
                  </tr>
                </thead>
                <tbody>
                  {auditLogs.map((log) => (
                    <tr key={log.id} className="border-b hover:bg-gray-50">
                      <td className="py-3 px-4 text-sm text-gray-600">{formatDate(log.timestamp)}</td>
                      <td className="py-3 px-4 text-sm font-medium text-gray-900">{log.action}</td>
                      <td className="py-3 px-4 text-sm text-gray-600">{log.username}</td>
                      <td className="py-3 px-4 text-sm text-gray-600">{log.ipAddress || '-'}</td>
                      <td className="py-3 px-4">
                        <span className={`px-2 py-1 rounded text-xs font-medium ${
                          log.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                        }`}>
                          {log.success ? 'Success' : 'Failed'}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </main>
    </div>
  );
}
</file>

<file path="frontend/src/services/api.ts">
// frontend/src/services/api.ts
import axios from 'axios';
import type { AuthResponse, LoginRequest, RegisterRequest, AuditLog, UserResponse } from '../types';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add token to requests if available
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Auth services
export const authService = {
  login: async (data: LoginRequest): Promise<AuthResponse> => {
    const response = await api.post<AuthResponse>('/api/auth/login', data);
    localStorage.setItem('token', response.data.token);
    return response.data;
  },

  register: async (data: RegisterRequest): Promise<AuthResponse> => {
    const response = await api.post<AuthResponse>('/api/auth/register', data);
    localStorage.setItem('token', response.data.token);
    return response.data;
  },

  logout: () => {
    localStorage.removeItem('token');
  },

  getToken: () => localStorage.getItem('token'),

  isAuthenticated: () => !!localStorage.getItem('token'),
};

// Audit services
export const auditService = {
  getRecentLogs: async (): Promise<AuditLog[]> => {
    const response = await api.get<AuditLog[]>('/api/audit/logs');
    return response.data;
  },

  getLogsByUsername: async (username: string): Promise<AuditLog[]> => {
    const response = await api.get<AuditLog[]>(`/api/audit/logs/user/${username}`);
    return response.data;
  },
};

// Health check
export const healthService = {
  check: async () => {
    const response = await api.get('/api/health');
    return response.data;
  },
};

// AI services
export const aiService = {
  chat: async (message: string): Promise<{ response: string; timestamp: string }> => {
    const response = await api.post('/api/ai/chat', { message });
    return response.data;
  },
};

// Admin services 
export const adminService = {
  getAllUsers: async (): Promise<UserResponse[]> => {
    const response = await api.get<UserResponse[]>('/api/admin/users');
    return response.data;
  },

  addRoleToUser: async (userId: number, roleName: string): Promise<UserResponse> => {
    const response = await api.post<UserResponse>(`/api/admin/users/${userId}/roles/${roleName}`);
    return response.data;
  },

  removeRoleFromUser: async (userId: number, roleName: string): Promise<UserResponse> => {
    const response = await api.delete<UserResponse>(`/api/admin/users/${userId}/roles/${roleName}`);
    return response.data;
  },
};

export default api;
</file>

<file path="README.md">
# AI Security Monitor

A full-stack IAM (Identity and Access Management) demonstration project featuring JWT authentication, role-based access control, audit logging, and AI-powered security assistance.

##  Live Demo

**Frontend:** https://ai-security-monitor.vercel.app

##  Features

- **Authentication:** JWT-based login and registration
- **RBAC:** Role-based access control (USER/ADMIN roles)
- **Audit Logging:** All security events logged with timestamps and IP addresses
- **AI Assistant:** Security-focused chat powered by Groq LLM
- **Responsive Design:** Mobile-first UI

##  Architecture
```
          
                                                             
  React Frontend   Kotlin Backend    PostgreSQL    
  (Vercel)              (Railway)              (Railway)     
                                                             
          
                                 
                                 
                        
                            Groq LLM     
                           (Cloud API)   
                        
```

##  Tech Stack

| Layer    | Technology                     |
|----------|--------------------------------|
| Frontend | React, TypeScript, Tailwind CSS |
| Backend  | Kotlin, Spring Boot 3.5        |
| Database | PostgreSQL 16                  |
| Auth     | JWT (jjwt), BCrypt             |
| AI       | Groq API (Llama 3.1)           |
| Deploy   | Vercel (frontend), Railway (backend) |

##  Local Development

### Prerequisites

- Docker and Docker Compose
- Node.js 20+
- Java 21+

### Quick Start (Docker)
```bash
# Clone the repository
git clone https://github.com/dannyp19921/ai-security-monitor.git
cd ai-security-monitor

# Set your Groq API key
export GROQ_API_KEY=your_key_here

# Start backend and database
docker-compose up -d

# Start frontend
cd frontend
npm install
npm run dev
```

Open http://localhost:5173 in your browser.

### Manual Setup

See [Backend README](./backend/README.md) and [Frontend README](./frontend/README.md) for detailed setup instructions.

##  Project Structure
```
ai-security-monitor/
 backend/                 # Kotlin Spring Boot API
    src/main/kotlin/
       com/securemonitor/
           config/      # Security, CORS configuration
           controller/  # REST endpoints
           dto/         # Data transfer objects
           model/       # JPA entities
           repository/  # Database repositories
           security/    # JWT filter and service
           service/     # Business logic
    Dockerfile
 frontend/                # React TypeScript app
    src/
       components/      # Reusable UI components
       hooks/           # Custom React hooks
       pages/           # Page components
       services/        # API clients
       types/           # TypeScript interfaces
 docker-compose.yml       # Local development setup
```

##  API Endpoints

| Method | Endpoint                  | Auth     | Description           |
|--------|---------------------------|----------|-----------------------|
| GET    | /api/health               | Public   | Health check          |
| POST   | /api/auth/register        | Public   | Register new user     |
| POST   | /api/auth/login           | Public   | Login, returns JWT    |
| GET    | /api/audit/logs           | Required | Get audit logs        |
| POST   | /api/ai/chat              | Required | Chat with AI assistant|

##  Author

Daniel-Aston Brandsgrd Parker

##  License

MIT
</file>

<file path="backend/src/main/kotlin/com/securemonitor/config/SecurityConfig.kt">
// backend/src/main/kotlin/com/securemonitor/config/SecurityConfig.kt
package com.securemonitor.config

import com.securemonitor.security.JwtAuthenticationFilter
import com.securemonitor.security.OAuth2AuthenticationSuccessHandler
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Lazy
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
import org.springframework.web.cors.CorsConfiguration
import org.springframework.web.cors.CorsConfigurationSource
import org.springframework.web.cors.UrlBasedCorsConfigurationSource

/**
 * Security configuration for the application.
 * 
 * Configures:
 * - CORS settings
 * - CSRF protection (disabled for stateless JWT auth)
 * - Session management (stateless for API, stateful for OAuth2)
 * - Endpoint authorization rules
 * - JWT authentication filter
 * - OAuth2 Login (Google)
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
class SecurityConfig(
    private val jwtAuthenticationFilter: JwtAuthenticationFilter,
    @Lazy private val oauth2SuccessHandler: OAuth2AuthenticationSuccessHandler
) {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .cors { it.configurationSource(corsConfigurationSource()) }
            .csrf { it.disable() }
            .sessionManagement { 
                // Use stateless sessions for API endpoints
                // OAuth2 login may need session for the login flow
                it.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
            }
            .authorizeHttpRequests { auth ->
                auth
                    // Public health check
                    .requestMatchers("/api/health").permitAll()
                    
                    // Authentication endpoints
                    .requestMatchers("/api/auth/**").permitAll()
                    
                    // OAuth 2.0 / OIDC Provider public endpoints
                    .requestMatchers("/.well-known/openid-configuration").permitAll()
                    .requestMatchers("/.well-known/jwks.json").permitAll()
                    .requestMatchers("/oauth2/authorize").permitAll() // Requires auth inside handler
                    .requestMatchers("/oauth2/token").permitAll()
                    
                    // OAuth 2.0 Provider protected endpoints
                    .requestMatchers("/oauth2/userinfo").authenticated()
                    
                    // Admin endpoints
                    .requestMatchers("/api/admin/**").hasRole("ADMIN")
                    
                    // All other requests require authentication
                    .anyRequest().authenticated()
            }
            // OAuth2 Login (Consumer - Sign in with Google)
            .oauth2Login { oauth2 ->
                oauth2
                    .successHandler(oauth2SuccessHandler)
                    // You can customize more here:
                    // .loginPage("/custom-login") // Custom login page
                    // .failureUrl("/login?error=true") // Failure redirect
            }
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)

        return http.build()
    }

    @Bean
    fun corsConfigurationSource(): CorsConfigurationSource {
        val configuration = CorsConfiguration()
        configuration.allowedOrigins = listOf(
            "http://localhost:5173",
            "http://localhost:3000",
            "http://127.0.0.1:5173",
            "http://127.0.0.1:3000",
            "https://ai-security-monitor.vercel.app"
        )
        configuration.allowedMethods = listOf("GET", "POST", "PUT", "DELETE", "OPTIONS")
        configuration.allowedHeaders = listOf("*")
        configuration.exposedHeaders = listOf("Location") // For OAuth2 redirects
        configuration.allowCredentials = true

        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", configuration)
        return source
    }

    @Bean
    fun passwordEncoder(): PasswordEncoder {
        return BCryptPasswordEncoder()
    }
}
</file>

<file path="backend/src/main/resources/application.yml">
# backend/src/main/resources/application.yml
spring:
  application:
    name: ai-security-monitor

  datasource:
    url: jdbc:postgresql://${PGHOST:localhost}:${PGPORT:5432}/${PGDATABASE:securemonitor}
    username: ${PGUSER:securemonitor}
    password: ${PGPASSWORD:localdev123}
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        format_sql: true

  # Spring Security OAuth2 Client Configuration
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - openid
              - profile
              - email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
        provider:
          google:
            issuer-uri: https://accounts.google.com

server:
  port: ${PORT:8080}

# JWT Configuration
jwt:
  secret: ${JWT_SECRET:myDefaultSecretKeyThatIsAtLeast256BitsLong123456}
  expiration: 86400000 # 24 hours in milliseconds

# OAuth 2.0 / OIDC Configuration
oauth2:
  issuer: ${OAUTH2_ISSUER:http://localhost:8080}
  access-token-lifetime: 3600      # 1 hour
  refresh-token-lifetime: 2592000  # 30 days
  authorization-code-lifetime: 600 # 10 minutes
  require-pkce: true

# Groq AI Configuration
groq:
  api-key: ${GROQ_API_KEY:}
  model: llama-3.1-8b-instant

# Logging
logging:
  level:
    com.securemonitor: DEBUG
    com.securemonitor.oauth2: DEBUG
    org.springframework.security: INFO
</file>

</files>
